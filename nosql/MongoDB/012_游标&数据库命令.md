# 游标&数据库命令

## 1 limit、skip 和 sort

### 1.1 limit

与关系型数据库的 `LIMIT` 类似：

```js
> db.c.find().limit(3)
```

### 1.2 skip

与关系型数据库的 `OFFSET` 类似：

```js
> db.c.find().skip(3)
```

### 1.3 sort

`sort` 接受一个对象作为参数，键对应文档的键名，值代表排序的方向，1 升序 -1 降序。如果指定了多个键，则按照这些键被指定的顺序逐个排序。

例如，要按照 `username` 升序及 `age` 降序排序，可以这样写：

```js
> db.c.find().sort({"username": 1, age: -1})
```

### 1.4 比较顺序

`MongoDB` 处理不同类型的数据是有一定顺序的。有时一个键可能是多种类型，其排序顺序是预先定义好的。优先级由小到大，顺序如下：

最小值 > null > 数字(整型，长整型，双精度) > 字符串 > 对象/文档 > 数组 > 二进制数据 > 对象 ID > 布尔型 > 日期型 > 时间戳 > 正则表达式 > 最大值

### 1.5 避免使用 skip 略过大量结果

用 `skip` 略过少量的文档还是不错的。但是要是数量非常多的话，`skip` 就会变得很慢，因为要先找到需要被略过的数据，再抛弃这些数据。大多数数据库都会在索引中保存更多的元数据，用于处理 `skip`，但是 `MongoDB` 目前还不支持，所以要尽量避免略过太多数据。通常可以利用上次的结果来计算下一次查询条件。

## 2 数据库命令

有一种非常特殊的查询类型叫做**数据库命令(database command)**。前面已经介绍过文档的 CRUD。这些都是数据库命令的使用范畴，包括管理型的任务(如关闭服务器和克隆数据库)、统计集合内的文档数量以及执行聚合等。

在数据操作、管理以及监控中，数据库命令都是非常有用的。比如，删除集合使用 `drop` 数据库命令：

```js
> db.runCommand({"drop": "analytics"})
{ "nIndexesWas" : 1, "ns" : "analytics.analytics", "ok" : 1 }
```

也可以使用 `shell` 封装的辅助函数：

```js
> db.analytics.drop()
```

通常，只使用 `shell` 辅助函数就可以了，但是可能使用旧版本的 `shell` 连接到新版本的数据库上时，这个 `shell` 可能不支持新版数据库的一些命令，这时候就不得不直接使用 `runCommand()`。

在 `shell` 中运行 `db.listCommands()` 可以看到所有的数据库命令。

## 3 数据库命令工作原理

数据库命令总会返回一个包含 `ok` 键的文档，如果值为 1 说明命令执行成功。值为 0 则会带有额外的键 `errmsg` 表示执行失败的原因。

`MongoDB` 中的命令被实现为一种特殊类型的查询，这些特殊的查询会在 `$cmd` 集合上执行。`runCommand` 只是接受一个命令文档，并且执行与这个命令文档等价的查询。

所以，`drop` 命令会被转换为：

```js
db.$cmd.findOne({"drop": "analytics"})
```

当 `MongoDB` 服务器得到一个在 `$cmd` 集合上的查询时，不会对这个查询进行通常的查询处理，而是会使用特殊的逻辑对其进行处理。几乎所有的 `MongoDB` 驱动程序都会提供一个类似 `runCommand` 的辅助函数，用于执行命令，而且命令总能够以简单查询的方式执行。

有些命令需要管理员权限，而且要在 `admin` 数据库上才能执行。如果在其他数据库上需要管理员权限，可以使用 `adminCommand` 而不是 `runCommand`：

```js
> use temp
> db.temp.adminCommand({"shutdown": 1})
```

`MongoDB` 中，数据库命令是少数与字段顺序相关的地方之一：命令名称必须是命令中的第一个字段。因此，`{"getLastError": 1, "w": 2}` 是有效的命令，而 `{"w": 2", getLastError": 1}` 不是。