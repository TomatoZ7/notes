# 聚合

## 1 聚合框架

使用聚合框架可以对集合中的文档进行变换和组合。可以用多个构建一个管道 (pipeline)，用于对一连串的文档进行处理。这些构件包括筛选(filtering)、投射(projecting)、分组(grouping)、排序(sorting)、限制(limiting) 和 跳过(skipping)。

例如，有一个保存着杂志文章的集合，你可能希望找出发表文章最多的那个作者。假设每篇文章被保存为 `MongoDB` 中的一个文档，可以按照如下步骤创建管道。

1. 将每个文章文档中的作者投射出来。

2. 将作者按照名字排序，统计每个名字出现的次数。

3. 将作者按照名字出现次数降序排列。

4. 将返回结果限制为 5 个。

这里面的每一步都对应局和框架中的一个操作符：

1. `{"$project": {"author": 1}}`

这样可以将 `author` 从每个文档中投射出来。

2. `{"$group": {"_id": "$author", "count": {"$sum": 1}}`

这样就会将作者按照名字排序，某个作者的名字每出现一次，就会对这个作者的 `count` 加 1。

这里首先指定了需要进行分组的字段 `author`。这是由 `"_id": "$author"` 指定的。可以将这个操作想象为：这个操作执行完后，每个作者只对应一个结果文档，所以 `author` 就成了文档的唯一标识符 `_id`。

第二个字段的意思是为分组内每个文档的 `count` 字段加 1。注意，新加入的文档中并不会有 `count` 字段，这是 `$group` 创建的一个新字段。

3. `{"$sort": {"count": -1}}`

这个操作会对结果集中的文档根据 `count` 字段进行降序排列。

4. `{"$limit": 5}`

这个操作将最终的返回结果限制为当前结果中的前 5 个文档。

在 `MongoDB` 中实际运行时，要将这些操作分别传给 `aggregate()` 函数：

```js
> db.articles.aggregate({"$project": {"author": 1}},
... {"$group": {"_id": "$author", "count": {"$sum": 1}}},
... {"$sort": {"count": -1}},
... {"$limit": 5})
{
    "result" : [
        {
            "_id" : "R. L. Stine",                
            "count" : 430
        },
        {
            "_id" : "Edgar Wallace",
            "count" : 175
        },
        {
            "_id" : "Nora Roberts",
            "count" : 145
        },
        {
            "_id" : "Erle Stanley Gardner",
            "count" : 140
        },
        {
            "_id" : "Agatha Christie",
            "count" : 85
        }
    ],
    "ok" : 1
}
```

`aggregate()` 会返回一个文档数组，其中的内容是发表文章最多的 5 个作者。

如果管道没有给出预期的结果，就需要进行调试，调试时，可以逐个指定管道操作符，一步步推导出预期结果。

聚合的结果输出给客户端时必须要限制在 16 MB 以内(`MongoDB` 支持的最大响应消息大小)。

## 2 管道操作符

每个操作符都会接受一连串的文档，对这些文档做一些类型转换，最后转换后的文档作为结果传递给下一个操作符，最后一个操作符返回给客户端。

不同的管道操作符可以按任意顺序组合在一起使用，而且可以被重复任意多次。例如，可以先做 `$match`，然后 `$group`，然后再做 `$match`。

### 2.1 $match

`$match` 用于对文档集合进行筛选，之后就可以在筛选得到的文档子集上做聚合。例如，如果想对 `Oregon`(俄勒冈州，简写为 `OR`) 的用户做统计，就可以使用 `{"$match": {"state": "OR"}}`。`$match` 可以使用所有常规的查询操作符(`$gt`、`$lt`、`$in`等)。有一个例外需要注意：不能再 `$match` 中使用地理空间操作符。

通常，在实际使用中应该尽可能将 `$match` 放在管道的**前面位置**。这样做有两个好处：一是可以快速将不需要的文档过滤掉，以减少管道的工作量；二是如果在投射和分组之前执行了 `$match`，查询可以使用索引。

### 2.2 $project

使用 `$project` 可以从子文档中提取字段，可以重命名字段，还可以在这些字段上进行一些有意思的操作。

它的语法与查询中的第二个参数类似，如果在原来的集合上执行下面代码，返回的结果文档只包含一个 `author` 字段：

```js
> db.articles.aggregate({"$project": {"author": 1, "_id": 0}})
```

默认情况下，如果文档中存在 `_id` 字段，这个字段就会被返回。可以使用上面的代码将 `_id` 从结果文档中移除。包含或排除字段的规则与常规查询语法一致。

也可以将投射过的字段进行重命名。例如，可以将每个用户文档的 `_id` 在返回结果中重命名为 `userId`：

```js
> db.users.aggregate({"$project": {"userId": "$_id", "_id": 0}})
{
    "result" : [
        {
            "userId" : ObjectId("50e4b32427b160e099ddbee7")
        },
        {
            "userId" : ObjectId("50e4b32527b160e099ddbee8")
        }
        ..
    ],
    "ok" : 1
}
```

这里的 `$_id` 会被替换为 `_id` 字段的内容(可能是数值，也可能是字符串)。例如，`$tags.3` 会被替换为 `tags` 数组中的第 4 个元素。所以，上面例子中的 `$_id` 会被替换为进入管道的每个文档的 `_id` 字段的值。

注意，如果没有明确指定将 `_id` 排除，这个字段会被返回两次，一次为 `userId`，一次为 `_id`。

在对字段进行重命名时，`MongoDB` 并不会记录字段的历史名称。因此，如果在 `originalfieldname` 字段上有一个索引，聚合框架无法在下面的排序操作中使用这个索引，尽管我们可以一眼辨别 `newfieldname` 与 `originalfieldname` 表示同一个字段：

```js
> db.articles.aggregate({"$project": {"newfieldname": "$originalfieldname"}}, {"$sort": {"newfieldname": 1}})
```

所以，应该尽量在修改字段名称之前使用索引。