# 索引的类型

## 1 唯一索引

唯一索引可以确保集合的每一个文档的指定键都有唯一值。例如，如果想保证不同文档拥有不同的 `username` 键拥有不同的值，创建一个唯一索引就可以了：

```js
> db.users.ensureIndex({"username": 1}, {"unique": true})
```

向 `users` 集合插入相同的文档：

```js
> db.users.insert({"username": "bob"})
> db.users.insert({"username": "bob"})
E11000 duplicate key error index: test.users.$username_1 dup key: { : "bob" }
```

此时查看 `users` 集合只有一个 `username` 为 `bob` 的文档。发现有重复的键时抛出异常会影响效率，所以可以使用唯一索引来应对偶尔可能会出现的键重复问题，而不是在运行时对重复的键进行过滤。

`_id` 也是唯一索引，但是该索引是不可删除的，其他的唯一索引可以删除。

如果一个文档没有对应的键，索引会将其作为 `null` 存储。所以，如果对某个键建立了唯一索引，但插入了多个**缺少该索引键的文档**，由于集合已经存在一个该索引键值为 `null` 的文档而导致插入失败。

有些情况下，一个值可能**无法被索引**。**索引储桶(index bucket)** 的大小是有限制的，如果某个索引条目超出了它的限制，那么这个条目就不会包含在索引里。这样可能会造成使用这个索引进行查询时会有一个文档没有被查询到。

所有的字段都必须小于 1024 字节，才能包含在索引里。如果一个文档的字段由于太大不能包含在索引里，`MongoDB` 不会返回任何错误或者警告。也就是说，超过 1KB 大小的键不会受到唯一索引的约束：可以插入多个同样的 1KB 长的字符串。

### 1.1 复合唯一索引

复合唯一索引，单个键的值可以相同，但所有键的组合值必须是唯一的。

例如，如果有一个 `{"username": 1, "age": 1}` 上的唯一索引，下面的插入是合法的：

```js
> db.users.insert({"username": "bob"})
> db.users.insert({"username": "bob", "age": 23})
> db.users.insert({"username": "fred", "age": 23})
```

然而，如果试图再次插入这三个文档中的任意一个，都会导致键重复异常。

`GirdFS` 是 `MongoDB` 中存储大文件的标准方式，其中就用到了复合唯一索引。存储文件内容的集合有一个 `{"files_id": 1, "n": 1}` 上的复合唯一索引，因此文档的某一部分看起来可能会是下面这样：

```js
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 1}
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 2}
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 3}
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 4}
```

注意，所有的 `files_id` 的值都相同，但是 `n` 的值不同。

### 1.2 去除重复

在已有的集合上创建唯一索引时可能会失败，因为集合中已经存在重复的值了：

```js
> db.users.ensureIndex({"age" : 1}, {"unique" : true})
E11000 duplicate key error index: test.users.$age_1 dup key: { : 12 }
```

需要先对已有数据进行去重处理。

在极少数情况下，可能希望直接删除重复的值。创建索引时使用 `dropDups` 选项，如果遇到重复的值，第一个会被保留，之后的重复文档都会被删除。*(慎用)*

```js
> db.users.ensureIndex({"age" : 1}, {"unique" : true, "dropDups": true})
```

## 2 稀疏索引

上述提到唯一索引会把 `null` 看做值，所以无法将多个缺少唯一索引中的键的文档插入到集合中。这时候我们希望唯一索引只对包含相应键的文档生效。如果有一个存在也可能不存在的字段，但是当它存在时，它必须是唯一的，这时就可以将 `unique` 和 `sparse` 选项组合使用。

`MongoDB` 中的**稀疏索引(sparse index)** 与关系型数据库中的稀疏索引是完全不同的概念。基本上来说，`MongoDB` 中的稀疏索引只是不需要将每个文档都作为索引条目。

```js
> db.ensureIndex({"email": 1}, {"unique": true, "sqarse": true})
```

**稀疏索引不必是唯一的。**只要去掉 `unique` 选项，就可以创建一个**非唯一的稀疏索引**。

根据是否使用稀疏索引，同一个查询的返回结果可能会不同。假如有这样一个集合，其中的大部分文档都有一个 `x` 字段，但是有些没有：

```js
> db.foo.find()
{ "_id" : 0 }
{ "_id" : 1, "x" : 1 }
{ "_id" : 2, "x" : 2 }
{ "_id" : 3, "x" : 3 }
```

当在 `x` 上执行查询时，它会返回相匹配的文档：

```js
> db.foo.find({"x": {"$ne": 2}})
{ "_id" : 0 }
{ "_id" : 1, "x" : 1 }
{ "_id" : 3, "x" : 3 }
```

如果在 `x` 上创建一个稀疏索引，并且在查询中使用这个稀疏索引，`{"_id": 0}` 这个文档就不会被返回：

```js
> db.foo.find({"x": {"$ne": 2}})
{ "_id" : 1, "x" : 1 }
{ "_id" : 3, "x" : 3 }
```

如果需要得到不包含 `x` 键的文档，可以使用 `hint()` 强制全表扫描。