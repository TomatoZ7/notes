# 特殊的索引&集合

## 1 固定集合

一般情况下，`MongoDB` 的集合是动态创建的，可以自动扩容。

**固定集合**的大小是固定的，需要事先创建好，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_1.jpg)

向一个已经满了的固定集合插入数据，那么最老的文档会被删除以释放空间，新插入的文档会占据这块空间，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_2.jpg)

固定集合的访问模式与 `MongoDB` 的大部分集合不同：数据被顺序写入磁盘上的固定空间。因此它们在**碟式磁盘(spinning disk)**上的写入速度非常快，尤其是集合拥有专用磁盘时(这样就不会因为其他集合的一些随机性的写操作而"中断")。

**固定集合不能被分片**。

固定集合可以用于记录日志，尽管不够灵活，无法控制什么时候数据会被覆盖。

### 1.1 创建固定集合

固定集合必须在使用之前显示创建。在 `shell` 中，可以使用 `createCollection()`：

```js
> db.createCollection("stable_collection", {"capped": true, "size": 100000})
{ "ok" : true }
```

上面的命令创建了一个名为 `stable_collection`、大小为 100000 字节的固定集合。

除了大小，`createCollection` 还能够指定固定集合中文档的数量：

```js
> db.createCollection("stable_collection2", 
... {"capped": true, "size": 100000, "max": 100})
{ "ok" : true}
```

可以使用这种方式来保存最新的 10 则新闻，或者是将每个用户的文档数量限制为 1000。

**指定文档数量时也必须指定固定集合的大小**。两个条件不论谁先到达上限，就会触发淘汰机制。

固定集合创建后，就不能改变了，如果需要修改其属性，只能将它删除后再重建。因此，在创建大的固定集合之前应该先仔细架构好。

固定集合无法转为常规集合，但使用 `convertToCapped` 可以将常规集合转换为固定集合：

```js
> db.runCommand({"convertToCapped": "test", "size": 10000})
{ "ok" : true}
```

### 1.3 自然排序

对固定集合可以进行一种特殊的排序，成为**自然排序(natural sort)**。自然排序返回结果集中文档的顺序就是文档在磁盘上的顺序，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_3.jpg)

固定集合中文档是按照插入的顺序保存的，因此自然排序就是文档的插入顺序，也就是从旧按新排列的。当然，也可以从新到旧排列：

```js
> db.stable_collection.find().sort({"$natural": -1})
```

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_4.jpg)

### 1.4 循环游标

**循环游标(tailable cursor)** 是一种特殊的游标，当循环游标的结果集被取光后，游标不会被关闭。因此，当有新文档插入集合中时，循环游标会继续取到结果。由于普通集合并不维护文档的插入顺序，所以循环游标**只能用在固定集合上**。

循环游标的灵感来自 `tail -f` 命令，会尽可能久地持续提取输出结果。

循环游标通常用于当文档被插入到 "工作队列"(其实就是个固定集合) 时对新插入的文档进行处理。如果超过 10 分钟没有新的结果，循环游标就会被释放。因此，当游标被关闭时自动重新执行查询是非常重要的。下面是一个在 PHP 中使用循环游标的例子(不能在 `mongo shell` 中使用循环游标)：

```php
$cursor=$collection-＞find()-＞tailable();

while (true) {
    if (! $cursor-＞hasNext()) {
        if ($cursor-＞dead()) {
            break;
        }
        sleep(1);
    }
    else {
        while ($cursor-＞hasNext()) {
            do_stuff($cursor-＞getNext());
        }
    }
}
```

这个游标会不断对查询结果进行处理，或者是等待新的查询结果，直到游标被关闭(超过 10 分钟没有新的结果或者人为中止查询操作)。

### 1.5 没有 _id 索引的集合

如果在调用 `createCollection` 创建集合时指定 `autoIndexId` 为 `false` 时，创建集合就不会自动在 `_id` 上创建索引。

但是如果集合中没有 `_id` 索引，就无法复制它所在的 `mongod`。

在 2.2 版本之前，固定集合默认是没有 `_id` 索引的，除非显示地将 `autoIndexId` 设为 `true`。对于已经存在的旧版固定集合，可以使用你的应用程序来填充 `_id` 字段(大多数应用程序默认都会自动填充)，然后使用 `ensureIndex` 创建 `_id` 索引。

`_id` 索引必须是唯一索引。不同于其他索引，`_id` 索引已经创建就无法删除，所以应保证创建 `_id` 索引一次成功。如果 `_id` 不规范，那么只能删除集合再重建了。