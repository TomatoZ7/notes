# 特殊的索引&集合

## 1 固定集合

一般情况下，`MongoDB` 的集合是动态创建的，可以自动扩容。

**固定集合**的大小是固定的，需要事先创建好，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_1.jpg)

向一个已经满了的固定集合插入数据，那么最老的文档会被删除以释放空间，新插入的文档会占据这块空间，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_2.jpg)

固定集合的访问模式与 `MongoDB` 的大部分集合不同：数据被顺序写入磁盘上的固定空间。因此它们在**碟式磁盘(spinning disk)**上的写入速度非常快，尤其是集合拥有专用磁盘时(这样就不会因为其他集合的一些随机性的写操作而"中断")。

**固定集合不能被分片**。

固定集合可以用于记录日志，尽管不够灵活，无法控制什么时候数据会被覆盖。

### 1.1 创建固定集合

固定集合必须在使用之前显示创建。在 `shell` 中，可以使用 `createCollection()`：

```js
> db.createCollection("stable_collection", {"capped": true, "size": 100000})
{ "ok" : true }
```

上面的命令创建了一个名为 `stable_collection`、大小为 100000 字节的固定集合。

除了大小，`createCollection` 还能够指定固定集合中文档的数量：

```js
> db.createCollection("stable_collection2", 
... {"capped": true, "size": 100000, "max": 100})
{ "ok" : true}
```

可以使用这种方式来保存最新的 10 则新闻，或者是将每个用户的文档数量限制为 1000。

**指定文档数量时也必须指定固定集合的大小**。两个条件不论谁先到达上限，就会触发淘汰机制。

固定集合创建后，就不能改变了，如果需要修改其属性，只能将它删除后再重建。因此，在创建大的固定集合之前应该先仔细架构好。

固定集合无法转为常规集合，但使用 `convertToCapped` 可以将常规集合转换为固定集合：

```js
> db.runCommand({"convertToCapped": "test", "size": 10000})
{ "ok" : true}
```

### 1.3 自然排序

对固定集合可以进行一种特殊的排序，成为**自然排序(natural sort)**。自然排序返回结果集中文档的顺序就是文档在磁盘上的顺序，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_3.jpg)

固定集合中文档是按照插入的顺序保存的，因此自然排序就是文档的插入顺序，也就是从旧按新排列的。当然，也可以从新到旧排列：

```js
> db.stable_collection.find().sort({"$natural": -1})
```

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/nosql/MongoDB/images/mongo_special_4.jpg)

### 1.4 循环游标

**循环游标(tailable cursor)** 是一种特殊的游标，当循环游标的结果集被取光后，游标不会被关闭。因此，当有新文档插入集合中时，循环游标会继续取到结果。由于普通集合并不维护文档的插入顺序，所以循环游标**只能用在固定集合上**。

循环游标的灵感来自 `tail -f` 命令，会尽可能久地持续提取输出结果。

循环游标通常用于当文档被插入到 "工作队列"(其实就是个固定集合) 时对新插入的文档进行处理。如果超过 10 分钟没有新的结果，循环游标就会被释放。因此，当游标被关闭时自动重新执行查询是非常重要的。下面是一个在 PHP 中使用循环游标的例子(不能在 `mongo shell` 中使用循环游标)：

```php
$cursor=$collection->find()->tailable();

while (true) {
    if (! $cursor->hasNext()) {
        if ($cursor->dead()) {
            break;
        }
        sleep(1);
    }
    else {
        while ($cursor->hasNext()) {
            do_stuff($cursor->getNext());
        }
    }
}
```

这个游标会不断对查询结果进行处理，或者是等待新的查询结果，直到游标被关闭(超过 10 分钟没有新的结果或者人为中止查询操作)。

### 1.5 没有 _id 索引的集合

如果在调用 `createCollection` 创建集合时指定 `autoIndexId` 为 `false` 时，创建集合就不会自动在 `_id` 上创建索引。

但是如果集合中没有 `_id` 索引，就无法复制它所在的 `mongod`。

在 2.2 版本之前，固定集合默认是没有 `_id` 索引的，除非显示地将 `autoIndexId` 设为 `true`。对于已经存在的旧版固定集合，可以使用你的应用程序来填充 `_id` 字段(大多数应用程序默认都会自动填充)，然后使用 `ensureIndex` 创建 `_id` 索引。

`_id` 索引必须是唯一索引。不同于其他索引，`_id` 索引已经创建就无法删除，所以应保证创建 `_id` 索引一次成功。如果 `_id` 不规范，那么只能删除集合再重建了。

## 2 TTL 索引

对于覆盖固定集合的内容，我们拥有非常有限的控制权限。如果需要更加灵活的老化移出系统(age-out system)，可以使用 **TTL 索引(time-to-live index，具有生命周期的索引)**。

TTL 索引允许为每个文档设置一个超时时间。一个文档到达预设时间后就会被删除。这种类型的索引对于缓存问题(比如会话的保存)非常有用。

在 `ensureIndex` 中指定 `expireAfterSecs` 选项就可以创建一个 TTL 索引：

```js
// 超时时间为 24 小时
> db.foo.ensureIndex({"lastUpdated": 1}, {"expireAfterSecs": 60*60*24})
```

这样就在 `lastUpdated` 字段上建立一个 TTL 索引。如果一个文档的 `lastUpdated` 字段存在并且它的值是日期类型，当服务器时间比文档的 `lastUpdated` 字段的时间晚 `expireAfterSecs` 秒时，文档就会被删除。

`MongoDB` 每分钟对 TTL 索引进行一次清理，所以不应该依赖以秒为单位的时间保证索引的存活状态。可以使用 `collMod` 命令修改 `expireAfterSecs` 的值：

```js
> db.runCommand({"collMod": "someapp.cache", "expireAfterSecs": 3600})
```

一个集合可以有多个 TTL 索引。TTL 索引不能是复合索引，但是可以像常规索引一样用来优化排序和查询。

## 3 全文本索引

对于大块文本搜索，使用正则表达式匹配非常慢，使用**全文本索引**可以提高效率，如同内置了多种语言分词机制的支持一样。

创建全文本索引的**开销更大**，在一个操作频繁的集合上创建全文本索引可能会导致 `MongoDB` 过载，所以应该是离线或对性能没要求状态下创建全文本索引。

全文本索引也会导致比常规索引更严重的性能问题，因为所有字符创都需要分解、分词并保存。因此，拥有全文本索引的集合的写入性能可能会比没有拥有的要差。全文本索引也会降低分片时的数据迁移速度：迁移数据时所有的文本都需要重新进行索引。

老版本的 `MongoDB` 默认关闭该功能，需要手动启用：

```js
> db.adminCommand({"setParameter": 1, "textSearchEnabled": true})
```

<!-- 362 -->