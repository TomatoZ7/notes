# 查询

## 1 find

`MongoDB` 中使用 `find` 来进行查询。查询就是返回一个集合中文档的子集，子集的范围从 0 个文档到整个集合。`find` 的第一个参数是一个文档，用于指定查询条件。

空的查询文档 `{}` 会匹配集合的全部内容。要是不指定查询文档，默认就是 `{}`。如：

```js
> db.c.find()
```

将批量返回集合 c 中所有文档。

构建查询文档，对于基本数据类型，数值匹配数值，布尔类型匹配布尔类型，字符串匹配字符串，只要指定目标值即可。例如，想要查找 `age` 值为 27 的所有文档，直接将这样的键值对写进查询文档就好了：

```js
> db.users.find({"age": 27)
```

要是想匹配一个字符串，比如值为 `joe` 的 `username` 键，那么直接将键值对写在查询文档中即可：

```js
> db.users.find({"username": "joe"})
```

可以向查询文档中写入多个键值对，这样与 `MySQL` 的 `AND` 操作符一致。

```js
> db.users.find({"username": "joe", "age": 27})
```

### 1.1 指定需要返回的键

`find` 或 `findOne` 的第二个参数指定了想要查找的键。这样做既会节省传输的数据量，又能节省客户端解码文档的时间和内存消耗。

```js
> db.users.find({}, {"username": 1, "email": 1})
{
    "_id": ObjectId("4ba0f0dfd22aa494fd523620"),
    "username": "joe",
    "email": "joe@example.com"
}
```

默认情况下 `_id` 键总是返回，即便没有指定。

也可以用第二个参数来剔除不需要的键(包括 `_id`)：

```js
> db.users.find({}, {"username": 1, "_id": 0})
{
    "username": "joe"
}
```

### 1.2 限制

查询使用上有些限制。传递给数据库的查询文档的值必须是常量(在你自己的代码里可以是正常的变量)，也就是不能引用文档中其他键的值。

例如，要想保持库存，有 `stock` (库存) 和 `num_sold` (已出售) 两个键，想通过下列查询来比较两者的值是行不通的：

```js
> db.stock.find({"stock": "this.num_sold"})
```

## 2 查询条件

### 2.1 比较

`$lt`、`$gt`、`lte`、`gte` 分别对应 `<`、`>`、`<=`、`>=`，它们之间可以互相组合使用。

例如，查询 18 ~ 30 岁的用户：

```js
> db.users.find({"age": {"$gte": 18, "$lte": 30}})
```

`$ne` 表示 `!=`，能够用于所有的数据类型：

```js
> db.users.find({"age": {"$ne": 24}})
```

### 2.2 OR 查询

`$in` 可以查询一个键的多个值，类似于 `MySQL` 的 `WHERE IN`。

`$or` 可以在多个键中查询任意的给定值。

#### 2.2.1 $in

例如，一次抽奖活动的中奖号码是 725、542 和 390。要找出全部的中奖文档的话，可以构建如下查询：

```js
> db.raffle.find({"ticket_no": {"$in": [725, 542, 390]}})
```

`$in` 非常灵活，可以指定不同类型的条件和值。例如，在逐步将用户的 ID 号迁移成用户名的过程中，查询时需要同时匹配 `ID` 和用户名：

```js
> db.users.find({"user_id": {"$in": [12345, "joe"]}})
```

这会匹配 `user_id` 等于 12345 的文档，也会匹配 `user_id` 等于 `joe` 的文档。

与 `$in` 相对的是 `$nin`，会返回所有条件不匹配的文档。

要是想返回所有没有中奖的人：

```js
> db.raffle.find({"ticket_no": {"$nin": [725, 542, 390]}})
```

#### 2.2.2 $or

如果想找到 `ticket_no` 为 725 或者 `winner` 为 `true` 的文档，可以使用 `$or`：

```js
> db.raffle.find({"$or": [{"ticket_no": 725}, {"winner": true}]})
```

`$or` 可以包含其他条件，如：

```js
> db.raffle.find({"$or": [{"ticket_no": {"$in": [725, 542, 390]}}, {"winner": true}]})
```

使用普通的 `AND` 型查询时，总是希望尽可能用最少的条件来限定结果的范围。`OR` 型查询正好相反，第一个条件应该尽可能匹配更多的文档，这样才是最高效的。

`$or` 在任何情况下都会正常工作。如果查询优化器可以更高效地处理 `$in`，那就选择使用它。