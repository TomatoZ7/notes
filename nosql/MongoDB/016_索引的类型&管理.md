# 索引的类型&管理

## 1 唯一索引

唯一索引可以确保集合的每一个文档的指定键都有唯一值。例如，如果想保证不同文档拥有不同的 `username` 键拥有不同的值，创建一个唯一索引就可以了：

```js
> db.users.ensureIndex({"username": 1}, {"unique": true})
```

向 `users` 集合插入相同的文档：

```js
> db.users.insert({"username": "bob"})
> db.users.insert({"username": "bob"})
E11000 duplicate key error index: test.users.$username_1 dup key: { : "bob" }
```

此时查看 `users` 集合只有一个 `username` 为 `bob` 的文档。发现有重复的键时抛出异常会影响效率，所以可以使用唯一索引来应对偶尔可能会出现的键重复问题，而不是在运行时对重复的键进行过滤。

`_id` 也是唯一索引，但是该索引是不可删除的，其他的唯一索引可以删除。

如果一个文档没有对应的键，索引会将其作为 `null` 存储。所以，如果对某个键建立了唯一索引，但插入了多个**缺少该索引键的文档**，由于集合已经存在一个该索引键值为 `null` 的文档而导致插入失败。

有些情况下，一个值可能**无法被索引**。**索引储桶(index bucket)** 的大小是有限制的，如果某个索引条目超出了它的限制，那么这个条目就不会包含在索引里。这样可能会造成使用这个索引进行查询时会有一个文档没有被查询到。

所有的字段都必须小于 1024 字节，才能包含在索引里。如果一个文档的字段由于太大不能包含在索引里，`MongoDB` 不会返回任何错误或者警告。也就是说，超过 1KB 大小的键不会受到唯一索引的约束：可以插入多个同样的 1KB 长的字符串。

### 1.1 复合唯一索引

复合唯一索引，单个键的值可以相同，但所有键的组合值必须是唯一的。

例如，如果有一个 `{"username": 1, "age": 1}` 上的唯一索引，下面的插入是合法的：

```js
> db.users.insert({"username": "bob"})
> db.users.insert({"username": "bob", "age": 23})
> db.users.insert({"username": "fred", "age": 23})
```

然而，如果试图再次插入这三个文档中的任意一个，都会导致键重复异常。

`GirdFS` 是 `MongoDB` 中存储大文件的标准方式，其中就用到了复合唯一索引。存储文件内容的集合有一个 `{"files_id": 1, "n": 1}` 上的复合唯一索引，因此文档的某一部分看起来可能会是下面这样：

```js
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 1}
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 2}
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 3}
{"files_id" : ObjectId("4b23c3ca7525f35f94b60a2d"), "n" : 4}
```

注意，所有的 `files_id` 的值都相同，但是 `n` 的值不同。

### 1.2 去除重复

在已有的集合上创建唯一索引时可能会失败，因为集合中已经存在重复的值了：

```js
> db.users.ensureIndex({"age" : 1}, {"unique" : true})
E11000 duplicate key error index: test.users.$age_1 dup key: { : 12 }
```

需要先对已有数据进行去重处理。

在极少数情况下，可能希望直接删除重复的值。创建索引时使用 `dropDups` 选项，如果遇到重复的值，第一个会被保留，之后的重复文档都会被删除。*(慎用)*

```js
> db.users.ensureIndex({"age" : 1}, {"unique" : true, "dropDups": true})
```

## 2 稀疏索引

上述提到唯一索引会把 `null` 看做值，所以无法将多个缺少唯一索引中的键的文档插入到集合中。这时候我们希望唯一索引只对包含相应键的文档生效。如果有一个存在也可能不存在的字段，但是当它存在时，它必须是唯一的，这时就可以将 `unique` 和 `sparse` 选项组合使用。

`MongoDB` 中的**稀疏索引(sparse index)** 与关系型数据库中的稀疏索引是完全不同的概念。基本上来说，`MongoDB` 中的稀疏索引只是不需要将每个文档都作为索引条目。

```js
> db.ensureIndex({"email": 1}, {"unique": true, "sqarse": true})
```

**稀疏索引不必是唯一的。**只要去掉 `unique` 选项，就可以创建一个**非唯一的稀疏索引**。

根据是否使用稀疏索引，同一个查询的返回结果可能会不同。假如有这样一个集合，其中的大部分文档都有一个 `x` 字段，但是有些没有：

```js
> db.foo.find()
{ "_id" : 0 }
{ "_id" : 1, "x" : 1 }
{ "_id" : 2, "x" : 2 }
{ "_id" : 3, "x" : 3 }
```

当在 `x` 上执行查询时，它会返回相匹配的文档：

```js
> db.foo.find({"x": {"$ne": 2}})
{ "_id" : 0 }
{ "_id" : 1, "x" : 1 }
{ "_id" : 3, "x" : 3 }
```

如果在 `x` 上创建一个稀疏索引，并且在查询中使用这个稀疏索引，`{"_id": 0}` 这个文档就不会被返回：

```js
> db.foo.find({"x": {"$ne": 2}})
{ "_id" : 1, "x" : 1 }
{ "_id" : 3, "x" : 3 }
```

如果需要得到不包含 `x` 键的文档，可以使用 `hint()` 强制全表扫描。

## 3 索引管理

所有的数据库索引信息都存储在 `system.indexes` 集合中。这是一个保留集合，不能在其中插入或者删除文档。只能通过 `ensureIndex` 或者 `dropIndexes` 对其进行操作。

执行 `db.collectionName.getIndexes()` 来查看给定集合上的所有索引信息：

```js
> db.foo.getIndexes()
[
    {
        "v" : 1,
        "key" : {
            "_id" : 1
        },
        "ns" : "test.foo",
        "name" : "_id_"
    },
    {
        "v" : 1,
        "key" : {
            "y" : 1
        },
        "ns" : "test.foo",
        "name" : "y_1"
    },
    {
        "v" : 1,
        "key" : {
            "x" : 1,
            "y" : 1
        },
        "ns" : "test.foo",
        "name" : "x_1_y_1"
    }
]
```

重要的字段是 `key` 和 `name`。`key` 的顺序不同，索引也不同。对于很多的索引操作(比如 `dropIndex`)，这里的索引名称都可以被当做标识符使用。这里没有指明索引是否是多键索引。

`v` 字段只在内部使用，用于标识索引版本。如果你的索引不包含 `"v": 1` 这样的字段，说明它是以一种效率比较低旧方式存储的。将 `MongoDB` 升级到至少 2.0 版本，删除并重建这些索引，就可以把索引的存储方式升级到新的格式了。

## 4 修改索引

随着业务的不断变化，有些索引无法发挥出应有的作用，可以使用 `dropIndex` 命令删除索引：

```js
> db.people.dropIndex("x_1_y_1")
{ "nIndexesWas" : 3, "ok" : 1 }
```

参数是索引描述信息里的 `name` 字段。

新建索引是一件既费时又费资源的事情。默认情况下，`MongoDB` 会尽可能快地创建索引，**阻塞所有读写请求**，直到索引创建完成。如果希望在此过程中处理读写请求，可以在创建索引时指定 `background` 选项。这样在创建索引过程中有新的数据库请求需要处理，会暂停创建索引，但是仍然对应用程序性能有比较大的影响。

后台创建索引比前台创建索引慢得多。在已有文档上创建索引会比新创建索引再插入文档快一点。