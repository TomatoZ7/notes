# 索引

## 1 简介

数据库索引与书籍索引类似。有了索引就不需要查整本书，数据库可以直接在索引中查找，在索引中找到目标文档后，就可以直接跳转到目标文档的位置，这能使查找速度提高几个数量级。

不使用索引称为**全表扫描**。通常来说，应该尽量避免全表扫描，因为对于大集合来说，全表扫描的效率非常低。

### 1.1 创建索引

```js
> db.users.ensureIndex({"username": 1})
```

使用索引是有代价的：对于添加一个索引，每次写操作都将耗费更多的时间。这是因为，当数据发生变动时，`MongoDB` 不仅要更新文档，还要更新集合上所有索引。因此，`MongoDB` 限制每个集合上**最多只能有 64 个索引**。

## 2 复合索引简介

索引的值是按照一定顺序排列的，因此，使用索引键对文档进行排序非常快。然而，只有在优先使用索引键进行排序时，索引才有用。例如，下面的排序里，`username` 上的索引没什么作用：

```js
> db.users.find.sort({"age": 1, "username": 1})
```

为了优化类似排序，可能需要在 `age` 和 `username` 上建立索引：

```js
> db.users.ensureIndex({"age": 1, "username": 1})
```

这样就建立了一个**复合索引(compound index)**。在查询中包含多个排序方向或者多个需要条件判断的键，它会非常有用。复合索引就是一个建立在多个字段上的索引。

假如我们有一个 `users` 集合，如果在这个集合上执行一个不排序(称为**自然顺序**)的查询：

```js
＞ db.users.find({}, {"_id" : 0, "i" : 0, "created" : 0})
{ "username" : "user0", "age" : 69 }
{ "username" : "user1", "age" : 50 }
{ "username" : "user2", "age" : 88 }
{ "username" : "user3", "age" : 52 }
{ "username" : "user4", "age" : 74 }
{ "username" : "user5", "age" : 104 }
{ "username" : "user6", "age" : 59 }
{ "username" : "user7", "age" : 102 }
{ "username" : "user8", "age" : 94 }
{ "username" : "user9", "age" : 7 }
{ "username" : "user10", "age" : 80 }
...
```

如果使用 `{"age": 1, "username": 1}` 建立索引，这个索引大致会是这个样子：

```js
[0, "user100309"] -> 0x0c965148
[0, "user100334"] -> 0xf51f818e
[0, "user100479"] -> 0x00fd7934
...
[0, "user99985" ] -> 0xd246648f
[1, "user100156"] -> 0xf78d5bdd
[1, "user100187"] -> 0x68ab28bd
[1, "user100192"] -> 0x5c7fb621
...
[1, "user999920"] -> 0x67ded4b7
[2, "user100141"] -> 0x3996dd46
[2, "user100149"] -> 0xfce68412
[2, "user100223"] -> 0x91106e23
...
```

每一个索引条目都包含一个 `age` 和 `username` 字段，并且指向文档在磁盘上的存储位置。这里的 `age` 是严格升序排列的，`age` 相同的条目按照 `username` 升序排列。

`MongoDB` 使用这个索引取决于查询的类型。下面是三种主要的方式：

+ `db.users.find({"age": 21}).sort({"username": -1})`

这个一个**点查询(point query)**，用于查找单个值(尽管包含这个值的文档可能有多个)。由于索引中的第二个字段，查询结果已经是有序的了：`MongoDB` 可以从 `{"age": 21}` 匹配的最后一个索引开始，逆序依次遍历索引：

```js
[21, "user999977"] -> 0x9b3160cf
[21, "user999954"] -> 0xfe039231
[21, "user999902"] -> 0x719996aa
...
```

这种类型的查询是非常高效的：`MongoDB` 能够直接定位到正确的年龄，而且不需要对结果进行排序(因为只需要对数据进行逆序遍历就可以得到正确的顺序了)。

注意：排序方向并不重要：`MongoDB` 可以在任意方向上对索引进行遍历。

+ `db.users.find({"age": {"$gte": 21, "$lte": 30}})`

这个一个**多值查询(multi-value query)**，查找到多个值相匹配的文档。`MongoDB` 会使用索引中的第一个键 `age` 得到匹配的文档，如下所示：

```js
[21, "user100000"] -> 0x37555a81
[21, "user100069"] -> 0x6951d16f
[21, "user1001"]   -> 0x9a1f5e0c
[21, "user100253"] -> 0xd54bd959
[21, "user100409"] -> 0x824fef6c
[21, "user100469"] -> 0x5fba778b
...
[30, "user999775"] -> 0x45182d8c
[30, "user999850"] -> 0x1df279e9
[30, "user999936"] -> 0x525caa57
```

通常来说，如果 `MongoDB` 使用索引进行查询，那么查询结果文档通常是按照索引顺序排列的。

+ `db.users.find({"age": {"$gte": 21, "$lte": 30}}).sort({"username": 1})`

这是一个**多值查询**，与上一个类似，只是这次需要对查询结果进行排序。跟之前一样，`MongoDB` 会使用索引来匹配查询条件：

```js
[21, "user100000"] -＞ 0x37555a81
[21, "user100069"] -＞ 0x6951d16f
[21, "user1001"]   -＞ 0x9a1f5e0c
[21, "user100253"] -＞ 0xd54bd959
...
[22, "user100004"] -＞ 0x81e862c5
[22, "user100328"] -＞ 0x83376384
[22, "user100335"] -＞ 0x55932943
[22, "user100405"] -＞ 0x20e7e664
...
```

然而，使用这个索引得到的结果集中 `username` 是无序的，而查询要求结果以 `username` 升序排列，所以 `MongoDB` 需要先**在内存中对结果进行排序**，然后才能返回。因此，这个查询通常不如上一个高效。

当然，查询速度取决于有多少个文档与查询条件匹配，文档少，则查询速度快，文档多，则查询速度慢，甚至根本不能用。如果结果集的大小超过 32 MB，`MongoDB` 就会出错，拒绝对如此多的数据进行排序：

```js
Mon Oct 29 16:25:26 uncaught exception: error: {
    "$err" : "too much data for sort() with no index. add an index or specify a smaller limit",
    "code" : 10128
}
```

最后一个例子中，还可以使用另一个索引(同样的键，但是顺序调换了)：`{"username": 1, "age": 1}`。`MongoDB` 会反转所有的索引条目，但是会以你期望的顺序返回。`MongoDB`会根据索引中的 `age` 部分挑选出匹配的文档：

```js
["user0", 69]
["user1", 50]
["user10", 80]
["user100", 48]
["user1000", 111]
["user10000", 98]
["user100000", 21] -＞ 0x73f0b48d
["user100001", 60]
["user100002", 82]
["user100003", 27] -＞ 0x0078f55f
["user100004", 22] -＞ 0x5f0d3088
["user100005", 95]
...
```

这样非常好，因为**不需要在内存中对大量数据进行排序**。但是，`MongoDB` 不得不**扫描整个索引**以便找到所有匹配的文档。因此，如果对**查询结果的范围**做了限制，那么 `MongoDB` 在几次匹配之后就可以不再扫描索引，在这种情况下，**将排序键放在第一位**是一个非常好的策略。

可以通过 `hint` 来强制 `MongoDB` 使用某个特定的索引：

```js
> db.users.find({"age": {"$gte": 21, "$lte": 30}}).sort({"username": 1}).hint({"username": 1, "age": 1})
```

在实际应用程序中，`{"sortKey": 1,"queryCriteria": 1}` 索引通常是很有用的，因为大多数应用程序在一次查询中只需要得到查询结果最前面的少数结果，而不是所有可能的结果。而且，由于索引在内部的组织形式，这种方式非常易于扩展。

**索引本质上是树，最小的值在最左边的叶子上，最大的值在最右边的叶子上。**如果有一个日期类型的 `sortKey` (或是其他能够随时间增加的值)，当从左向右遍历这棵树时，实际上也花费不少时间。

因此，如果应用程序需要使用最近数据的机会多于较老的数据，那么 `MongoDB` 只需在内存中保留这棵树最右侧的分支(最近的数据)，而不必将整棵树刘再内存中。类似这样的索引是右平衡的(right balanced)，应该尽量让索引是右平衡的。

`_id` 索引就是一个典型的右平衡索引。