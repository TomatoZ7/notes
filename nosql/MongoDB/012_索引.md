# 索引

## 1 简介

数据库索引与书籍索引类似。有了索引就不需要查整本书，数据库可以直接在索引中查找，在索引中找到目标文档后，就可以直接跳转到目标文档的位置，这能使查找速度提高几个数量级。

不使用索引称为**全表扫描**。通常来说，应该尽量避免全表扫描，因为对于大集合来说，全表扫描的效率非常低。

### 1.1 创建索引

```js
> db.users.ensureIndex({"username": 1})
```

使用索引是有代价的：对于添加一个索引，每次写操作都将耗费更多的时间。这是因为，当数据发生变动时，`MongoDB` 不仅要更新文档，还要更新集合上所有索引。因此，`MongoDB` 限制每个集合上**最多只能有 64 个索引**。

## 2 复合索引简介

索引的值是按照一定顺序排列的，因此，使用索引键对文档进行排序非常快。然而，只有在优先使用索引键进行排序时，索引才有用。例如，下面的排序里，`username` 上的索引没什么作用：

```js
> db.users.find.sort({"age": 1, "username": 1})
```

为了优化类似排序，可能需要在 `age` 和 `username` 上建立索引：

```js
> db.users.ensureIndex({"age": 1, "username": 1})
```

这样就建立了一个**复合索引(compound index)**。在查询中包含多个排序方向或者多个需要条件判断的键，它会非常有用。复合索引就是一个建立在多个字段上的索引。

假如我们有一个 `users` 集合，如果在这个集合上执行一个不排序(称为**自然顺序**)的查询：

```js
＞ db.users.find({}, {"_id" : 0, "i" : 0, "created" : 0})
{ "username" : "user0", "age" : 69 }
{ "username" : "user1", "age" : 50 }
{ "username" : "user2", "age" : 88 }
{ "username" : "user3", "age" : 52 }
{ "username" : "user4", "age" : 74 }
{ "username" : "user5", "age" : 104 }
{ "username" : "user6", "age" : 59 }
{ "username" : "user7", "age" : 102 }
{ "username" : "user8", "age" : 94 }
{ "username" : "user9", "age" : 7 }
{ "username" : "user10", "age" : 80 }
...
```

如果使用 `{"age": 1, "username": 1}` 建立索引，这个索引大致会是这个样子：

```js
[0, "user100309"] -> 0x0c965148
[0, "user100334"] -> 0xf51f818e
[0, "user100479"] -> 0x00fd7934
...
[0, "user99985" ] -> 0xd246648f
[1, "user100156"] -> 0xf78d5bdd
[1, "user100187"] -> 0x68ab28bd
[1, "user100192"] -> 0x5c7fb621
...
[1, "user999920"] -> 0x67ded4b7
[2, "user100141"] -> 0x3996dd46
[2, "user100149"] -> 0xfce68412
[2, "user100223"] -> 0x91106e23
...
```

每一个索引条目都包含一个 `age` 和 `username` 字段，并且指向文档在磁盘上的存储位置。这里的 `age` 是严格升序排列的，`age` 相同的条目按照 `username` 升序排列。

`MongoDB` 使用这个索引取决于查询的类型。下面是三种主要的方式：

+ `db.users.find({"age": 21}).sort({"username": -1})`

这个一个**点查询(point query)**，用于查找单个值(尽管包含这个值的文档可能有多个)。由于索引中的第二个字段，查询结果已经是有序的了：`MongoDB` 可以从 `{"age": 21}` 匹配的最后一个索引开始，逆序依次遍历索引：

```js
[21, "user999977"] -> 0x9b3160cf
[21, "user999954"] -> 0xfe039231
[21, "user999902"] -> 0x719996aa
...
```

这种类型的查询是非常高效的：`MongoDB` 能够直接定位到正确的年龄，而且不需要对结果进行排序(因为只需要对数据进行逆序遍历就可以得到正确的顺序了)。

注意：排序方向并不重要：`MongoDB` 可以在任意方向上对索引进行遍历。

+ `db.users.find({"age": {"$gte": 21, "$lte": 30}})`

这个一个**多值查询(multi-value query)**，查找到多个值相匹配的文档。`MongoDB` 会使用索引中的第一个键 `age` 得到匹配的文档，如下所示：

```js
[21, "user100000"] -> 0x37555a81
[21, "user100069"] -> 0x6951d16f
[21, "user1001"]   -> 0x9a1f5e0c
[21, "user100253"] -> 0xd54bd959
[21, "user100409"] -> 0x824fef6c
[21, "user100469"] -> 0x5fba778b
...
[30, "user999775"] -> 0x45182d8c
[30, "user999850"] -> 0x1df279e9
[30, "user999936"] -> 0x525caa57
```

通常来说，如果 `MongoDB` 使用索引进行查询，name查询结果文档通常是按照索引顺序排列的。

+ `db.users.find({"age": {"$gte": 21, "$lte": 30}}).sort({"username": 1})`

这是一个**多值查询**，与上一个类似，只是这次需要对查询结果进行排序。跟之前一样，`MongoDB` 会使用索引来匹配查询条件：

```js
[21, "user100000"] -＞ 0x37555a81
[21, "user100069"] -＞ 0x6951d16f
[21, "user1001"]   -＞ 0x9a1f5e0c
[21, "user100253"] -＞ 0xd54bd959
...
[22, "user100004"] -＞ 0x81e862c5
[22, "user100328"] -＞ 0x83376384
[22, "user100335"] -＞ 0x55932943
[22, "user100405"] -＞ 0x20e7e664
...
```

然而，使用这个索引得到的结果集中 `username` 是无序的，而查询要求结果以 `username` 升序排列，所以 `MongoDB` 需要现在内存中对结果进行排序，然后才能返回。因此，这个查询通常不如上一个高效。

当然，查询速度取决于有多少个文档与查询条件匹配，文档少，则查询速度快，文档多，则查询速度慢，甚至根本不能用。如果结果集的大小超过 32 MB，`MongoDB` 就会出错，拒绝对如此多的数据进行排序：

```js
Mon Oct 29 16:25:26 uncaught exception: error: {
    "$err" : "too much data for sort() with no index. add an index or specify a smaller limit",
    "code" : 10128
}
```