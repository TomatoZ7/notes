# 索引

## 1 简介

数据库索引与书籍索引类似。有了索引就不需要查整本书，数据库可以直接在索引中查找，在索引中找到目标文档后，就可以直接跳转到目标文档的位置，这能使查找速度提高几个数量级。

不使用索引称为**全表扫描**。通常来说，应该尽量避免全表扫描，因为对于大集合来说，全表扫描的效率非常低。

### 1.1 创建索引

```js
> db.users.ensureIndex({"username": 1})
```

使用索引是有代价的：对于添加一个索引，每次写操作都将耗费更多的时间。这是因为，当数据发生变动时，`MongoDB` 不仅要更新文档，还要更新集合上所有索引。因此，`MongoDB` 限制每个集合上**最多只能有 64 个索引**。

## 2 复合索引简介

索引的值是按照一定顺序排列的，因此，使用索引键对文档进行排序非常快。然而，只有在优先使用索引键进行排序时，索引才有用。例如，下面的排序里，`username` 上的索引没什么作用：

```js
> db.users.find.sort({"age": 1, "username": 1})
```

为了优化类似排序，可能需要在 `age` 和 `username` 上建立索引：

```js
> db.users.ensureIndex({"age": 1, "username": 1})
```

这样就建立了一个**复合索引(compound index)**。在查询中包含多个排序方向或者多个需要条件判断的键，它会非常有用。复合索引就是一个建立在多个字段上的索引。

假如我们有一个 `users` 集合，如果在这个集合上执行一个不排序(称为**自然顺序**)的查询：

```js
> db.users.find({}, {"_id" : 0, "i" : 0, "created" : 0})
{ "username" : "user0", "age" : 69 }
{ "username" : "user1", "age" : 50 }
{ "username" : "user2", "age" : 88 }
{ "username" : "user3", "age" : 52 }
{ "username" : "user4", "age" : 74 }
{ "username" : "user5", "age" : 104 }
{ "username" : "user6", "age" : 59 }
{ "username" : "user7", "age" : 102 }
{ "username" : "user8", "age" : 94 }
{ "username" : "user9", "age" : 7 }
{ "username" : "user10", "age" : 80 }
...
```

如果使用 `{"age": 1, "username": 1}` 建立索引，这个索引大致会是这个样子：

```js
[0, "user100309"] -> 0x0c965148
[0, "user100334"] -> 0xf51f818e
[0, "user100479"] -> 0x00fd7934
...
[0, "user99985" ] -> 0xd246648f
[1, "user100156"] -> 0xf78d5bdd
[1, "user100187"] -> 0x68ab28bd
[1, "user100192"] -> 0x5c7fb621
...
[1, "user999920"] -> 0x67ded4b7
[2, "user100141"] -> 0x3996dd46
[2, "user100149"] -> 0xfce68412
[2, "user100223"] -> 0x91106e23
...
```

每一个索引条目都包含一个 `age` 和 `username` 字段，并且指向文档在磁盘上的存储位置。这里的 `age` 是严格升序排列的，`age` 相同的条目按照 `username` 升序排列。

`MongoDB` 使用这个索引取决于查询的类型。下面是三种主要的方式：

+ `db.users.find({"age": 21}).sort({"username": -1})`

这个一个**点查询(point query)**，用于查找单个值(尽管包含这个值的文档可能有多个)。由于索引中的第二个字段，查询结果已经是有序的了：`MongoDB` 可以从 `{"age": 21}` 匹配的最后一个索引开始，逆序依次遍历索引：

```js
[21, "user999977"] -> 0x9b3160cf
[21, "user999954"] -> 0xfe039231
[21, "user999902"] -> 0x719996aa
...
```

这种类型的查询是非常高效的：`MongoDB` 能够直接定位到正确的年龄，而且不需要对结果进行排序(因为只需要对数据进行逆序遍历就可以得到正确的顺序了)。

注意：排序方向并不重要：`MongoDB` 可以在任意方向上对索引进行遍历。

+ `db.users.find({"age": {"$gte": 21, "$lte": 30}})`

这个一个**多值查询(multi-value query)**，查找到多个值相匹配的文档。`MongoDB` 会使用索引中的第一个键 `age` 得到匹配的文档，如下所示：

```js
[21, "user100000"] -> 0x37555a81
[21, "user100069"] -> 0x6951d16f
[21, "user1001"]   -> 0x9a1f5e0c
[21, "user100253"] -> 0xd54bd959
[21, "user100409"] -> 0x824fef6c
[21, "user100469"] -> 0x5fba778b
...
[30, "user999775"] -> 0x45182d8c
[30, "user999850"] -> 0x1df279e9
[30, "user999936"] -> 0x525caa57
```

通常来说，如果 `MongoDB` 使用索引进行查询，那么查询结果文档通常是按照索引顺序排列的。

+ `db.users.find({"age": {"$gte": 21, "$lte": 30}}).sort({"username": 1})`

这是一个**多值查询**，与上一个类似，只是这次需要对查询结果进行排序。跟之前一样，`MongoDB` 会使用索引来匹配查询条件：

```js
[21, "user100000"] -> 0x37555a81
[21, "user100069"] -> 0x6951d16f
[21, "user1001"]   -> 0x9a1f5e0c
[21, "user100253"] -> 0xd54bd959
...
[22, "user100004"] -> 0x81e862c5
[22, "user100328"] -> 0x83376384
[22, "user100335"] -> 0x55932943
[22, "user100405"] -> 0x20e7e664
...
```

然而，使用这个索引得到的结果集中 `username` 是无序的，而查询要求结果以 `username` 升序排列，所以 `MongoDB` 需要先**在内存中对结果进行排序**，然后才能返回。因此，这个查询通常不如上一个高效。

当然，查询速度取决于有多少个文档与查询条件匹配，文档少，则查询速度快，文档多，则查询速度慢，甚至根本不能用。如果结果集的大小超过 32 MB，`MongoDB` 就会出错，拒绝对如此多的数据进行排序：

```js
Mon Oct 29 16:25:26 uncaught exception: error: {
    "$err" : "too much data for sort() with no index. add an index or specify a smaller limit",
    "code" : 10128
}
```

最后一个例子中，还可以使用另一个索引(同样的键，但是顺序调换了)：`{"username": 1, "age": 1}`。`MongoDB` 会反转所有的索引条目，但是会以你期望的顺序返回。`MongoDB`会根据索引中的 `age` 部分挑选出匹配的文档：

```js
["user0", 69]
["user1", 50]
["user10", 80]
["user100", 48]
["user1000", 111]
["user10000", 98]
["user100000", 21] -> 0x73f0b48d
["user100001", 60]
["user100002", 82]
["user100003", 27] -> 0x0078f55f
["user100004", 22] -> 0x5f0d3088
["user100005", 95]
...
```

这样非常好，因为**不需要在内存中对大量数据进行排序**。但是，`MongoDB` 不得不**扫描整个索引**以便找到所有匹配的文档。因此，如果对**查询结果的范围**做了限制，那么 `MongoDB` 在几次匹配之后就可以不再扫描索引，在这种情况下，**将排序键放在第一位**是一个非常好的策略。

可以通过 `hint` 来强制 `MongoDB` 使用某个特定的索引：

```js
> db.users.find({"age": {"$gte": 21, "$lte": 30}}).sort({"username": 1}).hint({"username": 1, "age": 1})
```

在实际应用程序中，`{"sortKey": 1,"queryCriteria": 1}` 索引通常是很有用的，因为大多数应用程序在一次查询中只需要得到查询结果最前面的少数结果，而不是所有可能的结果。而且，由于索引在内部的组织形式，这种方式非常易于扩展。

**索引本质上是树，最小的值在最左边的叶子上，最大的值在最右边的叶子上。**如果有一个日期类型的 `sortKey` (或是其他能够随时间增加的值)，当从左向右遍历这棵树时，实际上也花费不少时间。

因此，如果应用程序需要使用最近数据的机会多于较老的数据，那么 `MongoDB` 只需在内存中保留这棵树最右侧的分支(最近的数据)，而不必将整棵树刘再内存中。类似这样的索引是右平衡的(right balanced)，应该尽量让索引是右平衡的。

`_id` 索引就是一个典型的右平衡索引。

## 3 复合索引使用

### 3.1 选择键的方向

目前为止，我们所有的索引都是升序的。但是，如果需要在两个或更多查询条件上进行排序，可能需要让索引键的方向不同。

例如，假设我们要根据年龄从小到大，用户名从 Z 到 A 对上面的集合进行排序。

对于这个问题，之前的索引不再高效：每一个年龄分组内都是按照 `username` 升序排列，即 A 到 Z。对于按 `age` 升序排列按 `username` 降序排列这样的需求来说，用上面的索引得到的数据的顺序没什么用。

为了在不同方向上优化这个复合排序，需要使用与方向相匹配的索引。在这个例子中，可以使用 `{"age": 1, "username": -1}`，它会以下面的方式组织数据：

```js
[21, "user999977"] -> 0xe57bf737
[21, "user999954"] -> 0x8bffa512
[21, "user999902"] -> 0x9e1447d1
[21, "user999900"] -> 0x3a6a8426
[21, "user999874"] -> 0xc353ee06
...
[30, "user999936"] -> 0x7f39a81a
[30, "user999850"] -> 0xa979e136
[30, "user999775"] -> 0x5de6b77a
...
[30, "user100324"] -> 0xe14f8e4d
[30, "user100140"] -> 0x0f34d446
[30, "user100050"] -> 0x223c35b1
```

`age` 按照从小到大排列，在每一个年龄分组中，用户名是从 Z 到 A 排列的。

如果应用程序同时需要按照 `{"age": 1, "username": 1}` 优化排序，我们还需要创建一个这个方向上的索引。至于索引使用的方向，与排序方向相同就可以了。注意，相互反转的索引是等价的：`{"age": 1, "username": -1}` 适用的查询与 `{"age": -1, "username": 1}` 是完全一样的。

只有基于多个查询条件进行排序时，索引方向才是比较重要的。如果只是基于单一键进行排序，`MongoDB` 可以简单地从相反方向读取索引。只有在基于多键排序时，方向才变得重要。

### 3.2 使用覆盖索引(covered index)

当一个索引包含用户请求的所有字段，可以认为这个索引覆盖了本次查询。在实际中，应该优先使用覆盖索引，而不是去获取实际的文档。这样可以保证工作集比较小，尤其与右平衡索引一起使用时。

为了确保查询只使用索引就可以完成，最好指定不要返回 `_id` 字段(除非它是索引的一部分)。可能还需要对不需要查询的字段做索引，因此需要在编写时就在所需的查询速度和这种方式带来的开销之间做好权衡。

如果在覆盖索引上执行 `explain()`，`indexOnly` 字段要为 true。

如果在一个含有数组的字段上做索引，这个索引永远也无法覆盖查询。即便将数组字段从需要返回的字段中剔除，这样的索引仍然无法覆盖查询。

### 3.3 隐式索引

复合索引具有双重功能，而且对不同的查询可以表现为不同的索引。如果有一个 `{"age": 1, "username": 1}` 索引，`age` 字段会被自动排序，就好像有一个 `{"age": 1}` 索引一样。因此，这个复合索引可以当作 `{"age": 1}` 索引一样使用。

这个可以根据需要推广到尽可能多的键：如果有一个拥有 N 个键的索引，那么你同时得到了这 N 个键的前缀组成的索引。举例来说，如果有一个 `{"a": 1, "b": 1, "c": 1, ..., "z": 1}` 索引，那么，实际上我们也可以使用 `{"a": 1}`、 `{"a": 1, "b": 1}`、 `{"a": 1, "b": 1, "c": 1}` 等一系列索引。

注意，这些键的任意子集所组成的索引并不一定可用。例如，使用 `{"b": 1}` 或者 `{"a": 1, "c": 1}` 作为索引的查询时不会被优化的：只有能够使用索引前缀的查询才能从中受益。

## 4 $ 操作符如何使用索引

不同的查询使用索引的情况各不相同。

### 4.1 低效率的操作符

有一些查询完全无法使用索引，比如 `$where` 和 `$exist`，也有其他一些操作不能高效地使用索引。

如果 `x` 上有一个索引，查询不包含 `x` 键的文档可以使用这样的索引 `{{"x": {"$exists": false}}}`。然而，在索引中，不存在的字段和 `null` 字段的存储方式是一样的，查询必须遍历每一个文档检查这个值是否真的为 `null` 还是根本不存在。如果使用稀疏索引(sparse index)，就不能使用 `{"$exists": true}` 或 `{"$exists": false}`。

通常来说，取反的效率是比较低的。`$ne` 查询可以使用索引，但并不是很有效。因为必须要查看所有的索引条目，而不只是 `$ne` 指定的条目，不得不扫描整个索引。例如，这样的查询遍历的索引范围如下：

```js
> db.example.find({"i" : {"$ne" : 3}}).explain()
{
    "cursor" : "BtreeCursor i_1 multi",
    ...,
    "indexBounds" : {
        "i" : [
            [
                {
                    "$minElement" : 1
                },
                3
            ],
            [
                3,
                {
                    "$maxElement" : 1
                }
            ]
        ]
    },
    ...
}
```

这个查询查找了所有不等于 3 的索引条目。如果索引中值为 3 的条目非常多，那么这个查询的效率是很不错的，否则的话，这个查询就不得不检查几乎所有的索引条目。

`$not` 有时能够使用索引，但是通常它并不知道要如何使用索引。它能够对基本的范围和正则表达式进行反转(例如将 `"key": {"$lt": 7}` 转为 `"key": {"$gte": 7}`)。然而，大多数使用 `$not` 的查询都会退化为进行全表扫描。

`$nin` 就总是进行全表扫描。

如果需要快速执行一个这些类型的查询，可以试着找到另一个能够使用索引的语句，将其添加到查询中，这样就可以在 `MongoDB` 进行无索引匹配(non-indexed matching) 时先将结果集的文档数量减到一个比较小的水平。

假如我们要找出所有没有 `birthday` 字段的用户。如果我们指导从 3 月 20 开始，程序会为每一个新用户添加生日字段，那么就可以只查询 3 月 20 之前创建的用户：

```js
> db.users.find({"birthday": {"$exists": false}, "_id": {"$lt": march20Id}})
```

这个查询中的字段顺序无关紧要，`MongoDB` 会自动找出可以使用索引的字段，而无视查询中的字段顺序。

### 4.2 范围

复合索引使 `MongoDB` 能够高效地执行拥有多个语句的查询。设计基于多个字段的索引时，应该将会用于精确匹配的字段(比如 `{"x": "foo"}`) 放在索引的前面，将用于范围匹配的字段(比如 `{"y": {"$gt": 3, "$lt": 5}}`) 放在最后。这样，查询就可以先试用第一个索引键进行精确匹配，然后再使用第二个索引范围在这个结果集内部进行搜索。假设要使用 `{"age": 1, "username": 1}` 索引查询特定年龄和用户名范围内的文档，可以精确指定索引边界值：

```js
> db.users.find({"age" : 47,
... "username" : {"$gt" : "user5", "$lt" : "user8"}}).explain()
{
    "cursor" : "BtreeCursor age_1_username_1",
    "n" : 2788,
    "nscanned" : 2788,
    ...,
    "indexBounds" : {
        "age" : [
            [
                47,
                47
            ]
        ],
        "username" : [
            [
                "user5",
                "user8"
            ]
        ]
    },
    ...
}
```

这个查询会直接定位到 `age` 为 47 的索引条目，然后再其中搜索用户名介于 `user5` 和 `user8` 的条目。

反过来，加入使用 `{"username": 1, "age": 1}` 索引，这样就改变了查询计划(query plan)，查询必须先找到介于 `user5` 和 `user8` 之间的所有用户，然后再从中挑选 `age` 等于 47 的用户。

```js
> db.users.find({"age" : 47,
... "username" : {"$gt" : "user5", "$lt" : "user8"}}).explain()
{
    "cursor" : "BtreeCursor username_1_age_1",
    "n" : 2788,
    "nscanned" : 319499,
    ...,
    "indexBounds" : {
        "username" : [
            [
                "user5",
                "user8"
            ]
        ],
        "age" : [
            [
                47,
                47
            ]
        ]
    },
    "server" : "spock:27017"
}
```

本次查询中 `MongoDB` 中扫描的索引条目数量是前一个查询的 10 倍！在一次查询中使用两个范围通常会导致低效的查询计划。

### 4.3 OR 查询

`MongoDB` 在一次查询中只能使用一个索引。如果你在 `{"x": 1}` 上有一个索引，在 `{"y": 1}` 上也有一个索引，在 `{"x": 123, "y": 456}` 上进行查询时，`MongoDB` 会使用其中的一个索引，而不是两个一起用。

`$or` 是个例外，`$or` 可以对每个子句都是用索引，因为 `$or` 实际上是执行两次查询然后将结果集合并。

```js
> db.foo.find({"$or" : [{"x" : 123}, {"y" : 456}]}).explain()
{
    "clauses" : [
        {
                "cursor" : "BtreeCursor x_1",
                "isMultiKey" : false,
                "n" : 1,
                "nscannedObjects" : 1,
                "nscanned" : 1,
                                        "nscannedObjectsAllPlans" : 1,
                "nscannedAllPlans" : 1,
                "scanAndOrder" : false,
                "indexOnly" : false,
                "nYields" : 0,
                "nChunkSkips" : 0,
                "millis" : 0,
                "indexBounds" : {
                    "x" : [
                        [
                        123,
                        123
                    ]
                ]
            }
        },
        {
            "cursor" : "BtreeCursor y_1",
            "isMultiKey" : false,
            "n" : 1,
            "nscannedObjects" : 1,
            "nscanned" : 1,
            "nscannedObjectsAllPlans" : 1,
            "nscannedAllPlans" : 1,
            "scanAndOrder" : false,
            "indexOnly" : false,
            "nYields" : 0,
            "nChunkSkips" : 0,
            "millis" : 0,
            "indexBounds" : {
                "y" : [
                    [
                        456,
                        456
                    ]
                ]
            }
        }
    ],
    "n" : 2,
    "nscannedObjects" : 2,
    "nscanned" : 2,
    "nscannedObjectsAllPlans" : 2,
    "nscannedAllPlans" : 2,
    "millis" : 0,
    "server" : "spock:27017"
}
```

可以看到，这次的 `explain()` 输出结果由两次独立的查询组成。通常来说，执行两次查询再将结果合并的效率不如单次查询高，因此，应该尽可能使用 `$in` 而不是 `$or`。

如果不得不使用 `$or`，记住，`MongoDB` 需要检查每次查询的结果集并且从中移除重复的文档(有些文档可能会被多个 `$or` 子句匹配到)。

使用 `$in` 查询时无法控制返回文档的顺序(除非进行排序)。例如，使用 `{"x": [1,2,3]}` 与使用 `{"x": [3,2,1]}` 得到的文档顺序是相同的。

如果不得不使用 `$or`，记住，`MongoDB` 需要检查每次查询的结果集并且从中移除重复的文档(有些文档可能会被多个 `$or` 子句匹配到)。

使用 `$in` 查询时无法控制返回文档的顺序(除非进行排序)。例如，使用 `{"x": [1, 2, 3]}` 和使用 `{"x": [1, 2, 3]}` 得到的文档顺序是相同的。