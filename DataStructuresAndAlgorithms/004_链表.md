# 链表

相比数组，链表稍微复杂点。为了更好的区分，我们先从**底层的存储结构**上来比较：

如图所示，数组需要一块连续的内存空间来存储数据，对内存的要求比较高。如果我们申请 100 MB 大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存剩余空间大于 100 MB，也会申请失败。

而链表恰恰相反，它不需要连续的内存空间，而是使用指针将零散的内存块串联起来使用，所以针对上述问题如果我们申请的是 100 MB 的链表，根本不会有问题。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_1.jpg)

链表结构众多，主要包含单链表，双链表和循环链表。

## 1 单链表

单链表是最简单，也是最常用的。

链表通过指针将一组零散的内存块串联起来。其中，我们把内存块称为链表的**结点**。每个结点除了存储数据以外，为了串联数据，还需要记录下一个结点的位置。如图所示，我们记录下个结点地址的指针叫作**后继指针 next**。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_2.jpg)

图中有两个结点比较特殊，分别是第一个结点（头结点）和最后一个结点（尾结点）。头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。尾结点为一个空地址 `NULL`，表示链表的结尾。

与数组一样，链表也支持查找、插入和删除操作。

在数组中插入或删除元素时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 `O(n)`。而链表的存储空间本身就不是连续的，并不需要搬移数据，所以链表的插入和删除操作是非常快速的。针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 `O(1)`。

<!-- image -->

虽然链表插入很快，但是如果想随机访问第 `k` 个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，无法直接通过寻址公式计算出结点的内存地址，而是要遍历每个结点，直到找到目标结点。所以对应的时间复杂度是 `O(n)`。

## 2 循环链表

**循环链表是一种特殊的单链表。**它跟单链表最大的区别就是尾结点的指向问题，单链表的尾结点指向空地址，而循环链表的尾结点指向链表的头结点，如图所示：

<!-- image -->

与单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特别适合采用循环链表。

## 3 双向链表

单向链表只有一个方向，结点只有一个后继指针 `next` 指向后面的结点。而双向链表支持两个方向，每个结点不止有有个后继指针 `next` 指向后面的结点，还有一个前驱指针 `prev` 指向前面的结点。

<!-- image -->

从图中可以看出，双向链表需要额外的空间来存储前驱结点的地址。也就是说，数据相同的情况下，双向链表比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？

从结构上来看，双向链表可以支持 `O(1)` 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除操作都比单链表简单、高效。下面我们来具体讨论一下。

### 3.1 删除操作

在实际开发中，从链表中删除数据主要包括这 2 种情况：

1. 删除匹配给定值的结点；

2. 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，都需要从头结点开始一个一个遍历对比，直到找到值等于给定值的结点，再删除。需要 `O(n)` 的时间复杂度。

对于第二种情况，我们已经找到了要删除的结点，但是删除该结点需要直到它的前驱结点，如果是单链表，找到前驱结点需要在遍历一次链表，所需的时间复杂度是 `O(n)`，而双向链表可以通过前驱指针 `prev` 直接找到前驱结点，时间复杂度为 `O(1)`。比较之下，双向链表在这方面更具优势。