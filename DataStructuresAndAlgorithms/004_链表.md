# 链表

相比数组，链表稍微复杂点。为了更好的区分，我们先从**底层的存储结构**上来比较：

如图所示，数组需要一块连续的内存空间来存储数据，对内存的要求比较高。如果我们申请 100 MB 大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存剩余空间大于 100 MB，也会申请失败。

而链表恰恰相反，它不需要连续的内存空间，而是使用指针将零散的内存块串联起来使用，所以针对上述问题如果我们申请的是 100 MB 的链表，根本不会有问题。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_1.jpg)

链表结构众多，主要包含单链表，双链表和循环链表。

## 1 单链表

单链表是最简单，也是最常用的。

链表通过指针将一组零散的内存块串联起来。其中，我们把内存块称为链表的**结点**。每个结点除了存储数据以外，为了串联数据，还需要记录下一个结点的位置。如图所示，我们记录下个结点地址的指针叫作**后继指针 next**。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_2.jpg)

图中有两个结点比较特殊，分别是第一个结点（头结点）和最后一个结点（尾结点）。头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。尾结点为一个空地址 `NULL`，表示链表的结尾。

与数组一样，链表也支持查找、插入和删除操作。

在数组中插入或删除元素时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 `O(n)`。而链表的存储空间本身就不是连续的，并不需要搬移数据，所以链表的插入和删除操作是非常快速的。针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 `O(1)`。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_3.jpg)

虽然链表插入很快，但是如果想随机访问第 `k` 个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，无法直接通过寻址公式计算出结点的内存地址，而是要遍历每个结点，直到找到目标结点。所以对应的时间复杂度是 `O(n)`。

## 2 循环链表

**循环链表是一种特殊的单链表。**它跟单链表最大的区别就是尾结点的指向问题，单链表的尾结点指向空地址，而循环链表的尾结点指向链表的头结点，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_4.jpg)

与单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特别适合采用循环链表。

## 3 双向链表

单向链表只有一个方向，结点只有一个后继指针 `next` 指向后面的结点。而双向链表支持两个方向，每个结点不止有有个后继指针 `next` 指向后面的结点，还有一个前驱指针 `prev` 指向前面的结点。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_5.jpg)

从图中可以看出，双向链表需要额外的空间来存储前驱结点的地址。也就是说，数据相同的情况下，双向链表比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？

从结构上来看，双向链表可以支持 `O(1)` 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除操作都比单链表简单、高效。下面我们来具体讨论一下。

### 3.1 删除操作

在实际开发中，从链表中删除数据主要包括这 2 种情况：

1. 删除匹配给定值的结点；

2. 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，都需要从头结点开始一个一个遍历对比，直到找到值等于给定值的结点，再删除。需要 `O(n)` 的时间复杂度。

对于第二种情况，我们已经找到了要删除的结点，但是删除该结点需要直到它的前驱结点，如果是单链表，找到前驱结点需要在遍历一次链表，所需的时间复杂度是 `O(n)`，而双向链表可以通过前驱指针 `prev` 直接找到前驱结点，时间复杂度为 `O(1)`。比较之下，双向链表在这方面更具优势。

### 3.2 插入操作

同理，如果我们希望在指定结点前插入一个结点，那么双向链表所需的时间复杂度为 `O(1)`，单链表则为 `O(n)`。

### 3.3 按值查询

双向链表按值查询的效率也要比单链表高。因为我们可以记录上次查找的位置 `p`，每次查询时，根据要查找的值与 `p` 的大小关系，决定往前还是往后找，所以平均只需要查找一半的数据。

所以，在实际软件开发过程中，虽然双向链表比较费内存，但是比单链表的使用更加广泛，如 Java 的 `LinkedHashMap` 的实现原理就用到了双向链表。

> 这也是**空间换时间**的设计思想。当内存空间充足，如果我们更追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度相对很低的数据结构或算法，反之亦然。

### 4 双向循环链表

双向循环链表即双向链表+循环链表：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_6.jpg)

## 3 数组、链表性能对比

| | 数组 | 链表 |
| :-: | :-: | :-: |
| 插入删除 | O(n) | O(1) |
| 随机访问 | O(1) | O(n) | 

数组和链表的对比不能局限于时间复杂度，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一旦声明就需要占用整块连续的存储空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，就会导致**内存不足（out of memory）**。如果声明的数组过小，则可能出现不够用的情况，这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容。

> 以 Java 的 `ArrayList` 为例，虽然说是支持动态扩容，但是当数组没有空闲空间时，就会申请一个更大的空间，再把数据拷贝过去。

链表中的每个结点都需要消耗额外的内存去存储指向下一个结点的指针，所以内存消耗会翻倍。而且对内存进行频繁的插入或删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

## 4 LRU 缓存淘汰算法

缓存是一种提升数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等。

缓存的大小有限，当缓存被用满时，哪些数据应该先被清理出去，哪些数据应该保留，这就需要缓存淘汰策略来决定。常见的策略有三种：

+ 先进先出 FIFO（First In，First Out)

+ 最少使用 LFU（Least Frequently Used）

+ 最近最少使用 LRU（Least Recently Used）

那么如何基于链表实现 LRU 缓存淘汰算法？

思路大致如下：

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据存在于链表中，我们将其从原位置删除，再插入到链表头部；

2. 如果数据不存在于链表中，那么又可以分为：

+ 如果此时缓存未满，则直接插入链表头部；

+ 如果缓存已满，则链表尾结点删除，再插入头部。

我们分析一下时间复杂度：不管缓存有没有存满，我们都需要遍历一遍链表，所以这种基于链表的设计思路，缓存访问的时间复杂度为 `O(n)`。

## 5 编写链表代码要点

### 5.1 理解指针或引用的含义

有些语言有**指针**的概念，如 C 语言，而有些语言没有指针，取而代之的是**引用**，比如 Java、Python。不管是指针还是引用，它们表达的都是一个意思：都是存储所指对象的内存地址。

接下来将统一使用**指针**来讲解。

对于指针的理解，你只需要记住下面这句话就可以了：

**将某个变量赋值给指针，就是将这个变量的地址赋值给指针，反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

在编写链表代码的时候，我们经常会有这样的代码：`p->next = q`。这行代码是说，`p` 结点中的 `next` 指针存储了 `q` 结点的内存地址。还有一个更复杂的：`p->next = p->next->next`，这行代码表示 `p` 结点的 `next` 指针存储了 `p` 结点的下下一个结点的内存地址。