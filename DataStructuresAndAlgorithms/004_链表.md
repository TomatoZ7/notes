# 链表

相比数组，链表稍微复杂点。为了更好的区分，我们先从**底层的存储结构**上来比较：

如图所示，数组需要一块连续的内存空间来存储数据，对内存的要求比较高。如果我们申请 100 MB 大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存剩余空间大于 100 MB，也会申请失败。

而链表恰恰相反，它不需要连续的内存空间，而是使用指针将零散的内存块串联起来使用，所以针对上述问题如果我们申请的是 100 MB 的链表，根本不会有问题。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_1.jpg)

链表结构众多，主要包含单链表，双链表和循环链表。

## 1 单链表

单链表是最简单，也是最常用的。

链表通过指针将一组零散的内存块串联起来。其中，我们把内存块称为链表的**结点**。每个结点除了存储数据以外，为了串联数据，还需要记录下一个结点的位置。如图所示，我们记录下个结点地址的指针叫作**后继指针 next**。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_2.jpg)

图中有两个结点比较特殊，分别是第一个结点（头结点）和最后一个结点（尾结点）。头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。尾结点为一个空地址 `NULL`，表示链表的结尾。

与数组一样，链表也支持查找、插入和删除操作。

在数组中插入或删除元素时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 `O(n)`。而链表的存储空间本身就不是连续的，并不需要搬移数据，所以链表的插入和删除操作是非常快速的。针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 `O(1)`。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_3.jpg)

虽然链表插入很快，但是如果想随机访问第 `k` 个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，无法直接通过寻址公式计算出结点的内存地址，而是要遍历每个结点，直到找到目标结点。所以对应的时间复杂度是 `O(n)`。

## 2 循环链表

**循环链表是一种特殊的单链表。**它跟单链表最大的区别就是尾结点的指向问题，单链表的尾结点指向空地址，而循环链表的尾结点指向链表的头结点，如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_4.jpg)

与单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环形结构特点时，就特别适合采用循环链表。

## 3 双向链表

单向链表只有一个方向，结点只有一个后继指针 `next` 指向后面的结点。而双向链表支持两个方向，每个结点不止有有个后继指针 `next` 指向后面的结点，还有一个前驱指针 `prev` 指向前面的结点。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_5.jpg)

从图中可以看出，双向链表需要额外的空间来存储前驱结点的地址。也就是说，数据相同的情况下，双向链表比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？

从结构上来看，双向链表可以支持 `O(1)` 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除操作都比单链表简单、高效。下面我们来具体讨论一下。

### 3.1 删除操作

在实际开发中，从链表中删除数据主要包括这 2 种情况：

1. 删除匹配给定值的结点；

2. 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，都需要从头结点开始一个一个遍历对比，直到找到值等于给定值的结点，再删除。需要 `O(n)` 的时间复杂度。

对于第二种情况，我们已经找到了要删除的结点，但是删除该结点需要直到它的前驱结点，如果是单链表，找到前驱结点需要在遍历一次链表，所需的时间复杂度是 `O(n)`，而双向链表可以通过前驱指针 `prev` 直接找到前驱结点，时间复杂度为 `O(1)`。比较之下，双向链表在这方面更具优势。

### 3.2 插入操作

同理，如果我们希望在指定结点前插入一个结点，那么双向链表所需的时间复杂度为 `O(1)`，单链表则为 `O(n)`。

### 3.3 按值查询

双向链表按值查询的效率也要比单链表高。因为我们可以记录上次查找的位置 `p`，每次查询时，根据要查找的值与 `p` 的大小关系，决定往前还是往后找，所以平均只需要查找一半的数据。

所以，在实际软件开发过程中，虽然双向链表比较费内存，但是比单链表的使用更加广泛，如 Java 的 `LinkedHashMap` 的实现原理就用到了双向链表。

> 这也是**空间换时间**的设计思想。当内存空间充足，如果我们更追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度相对很低的数据结构或算法，反之亦然。

### 4 双向循环链表

双向循环链表即双向链表+循环链表：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_6.jpg)

## 3 数组、链表性能对比

| | 数组 | 链表 |
| :-: | :-: | :-: |
| 插入删除 | O(n) | O(1) |
| 随机访问 | O(1) | O(n) | 

数组和链表的对比不能局限于时间复杂度，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一旦声明就需要占用整块连续的存储空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，就会导致**内存不足（out of memory）**。如果声明的数组过小，则可能出现不够用的情况，这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容。

> 以 Java 的 `ArrayList` 为例，虽然说是支持动态扩容，但是当数组没有空闲空间时，就会申请一个更大的空间，再把数据拷贝过去。

链表中的每个结点都需要消耗额外的内存去存储指向下一个结点的指针，所以内存消耗会翻倍。而且对内存进行频繁的插入或删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

## 4 LRU 缓存淘汰算法

缓存是一种提升数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等。

缓存的大小有限，当缓存被用满时，哪些数据应该先被清理出去，哪些数据应该保留，这就需要缓存淘汰策略来决定。常见的策略有三种：

+ 先进先出 FIFO（First In，First Out)

+ 最少使用 LFU（Least Frequently Used）

+ 最近最少使用 LRU（Least Recently Used）

那么如何基于链表实现 LRU 缓存淘汰算法？

思路大致如下：

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据存在于链表中，我们将其从原位置删除，再插入到链表头部；

2. 如果数据不存在于链表中，那么又可以分为：

+ 如果此时缓存未满，则直接插入链表头部；

+ 如果缓存已满，则链表尾结点删除，再插入头部。

我们分析一下时间复杂度：不管缓存有没有存满，我们都需要遍历一遍链表，所以这种基于链表的设计思路，缓存访问的时间复杂度为 `O(n)`。

## 5 编写链表代码要点

### 5.1 理解指针或引用的含义

有些语言有**指针**的概念，如 C 语言，而有些语言没有指针，取而代之的是**引用**，比如 Java、Python。不管是指针还是引用，它们表达的都是一个意思：都是存储所指对象的内存地址。

接下来将统一使用**指针**来讲解。

对于指针的理解，你只需要记住下面这句话就可以了：

**将某个变量赋值给指针，就是将这个变量的地址赋值给指针，反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

在编写链表代码的时候，我们经常会有这样的代码：`p->next = q`。这行代码是说，`p` 结点中的 `next` 指针存储了 `q` 结点的内存地址。还有一个更复杂的：`p->next = p->next->next`，这行代码表示 `p` 结点的 `next` 指针存储了 `p` 结点的下下一个结点的内存地址。

### 5.2 警惕指针丢失和内存泄漏

假设有 A、B 两个结点，其中 A 结点指向 B 结点，即 `a->next = b`。现在要在 A、B 结点之间新插入一个 X 结点，如果我们将代码写成下面这样，就会造成指针丢失和内存泄漏：

```java
a->next = x;
x->next = a->next;
```

需要警惕的是，当完成第一行代码执行之后，`a->next` 指针已经不再指向 B 结点了，而是指向 X 结点。如果此时再将 `x->next` 指针指向自己，那么整个链表就断开了，从 B 结点开始往后的结点都将无法访问。

对于有些语言如 C 语言来说，内存管理是由呈现出员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄漏。所以，我们插入结点时，一定要注意操作的顺序，正确的做法是将上述 1、2 行代码的顺序颠倒一下即可。

同理，删除链表结点时，也一定要记得手动释放内存空间。否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

### 5.3 利用哨兵简化实现难度

首先，我们先来回顾一下单链表的插入与删除操作。如果我们在结点 `p` 后面插入一个新的节点，只需要 2 行代码就可以搞定：

```java
new_node->next = p->next
p->next = new_node
```

但是，当我们要向空链表插入第一个结点时，刚刚的代码就不能用了，我们需要做一些额外的判断：

```java
// head 表示链表的头结点
if (head == null) {
    head = new_node
}
```

我们再来看链表的删除操作。普通结点的删除操作只需要 1 行代码：

```java
p->next = p->next->next
```

但是，如果链表中仅剩一个结点，就需要加个判断了：

```java
if (head->next = null) {
    head = null
}
```

从前面的分析我们得出：针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，所以就需要**哨兵**的登场了。

还记得如何表示一个空链表吗？`head == null` 表示链表中没有结点了。其中 `head` 表示头结点指针，指向链表的第一个结点。

如果我们引入哨兵结点，在任何时候，不管链表是不是空，`head` 指针都会一直指向哨兵结点。我们也把这种带有哨兵结点的链表叫**带头链表**。反之叫做**不带头链表**。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_7.jpg)

如图所示，哨兵结点不存储数据，但是哨兵结点一直存在，所以插入第一个结点和插入其他结点、删除最后一个结点和删除其他结点，都可以用统一的代码逻辑实现了。

### 5.4 重点留意边界条件处理

常用的用来检查链表代码是否正确的边界条件有这样几个：

+ 链表为空

+ 链表只包含一个结点

+ 链表只包含两个结点

+ 处理头结点和尾结点

当你写完链表代码时，除了看下你写的代码是否正常运行外，也要看下在上面列举的几个边界条件下，代码能否正常工作。

### 5.5 举例画图，辅助思考

当无法更好的构思链表代码时，**举例法**和**画图法**往往很有用，正如我上面所画的图一样。

## 6、常见的链表操作、考察点

+ 单链表反转

+ 链表中有环的检测

+ 两个有序的链表合并

+ 删除链表倒数第 N 个结点

+ 求链表的中间结点