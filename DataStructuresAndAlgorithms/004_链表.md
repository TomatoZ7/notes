# 链表

相比数组，链表稍微复杂点。为了更好的区分，我们先从**底层的存储结构**上来比较：

如图所示，数组需要一块连续的内存空间来存储数据，对内存的要求比较高。如果我们申请 100 MB 大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存剩余空间大于 100 MB，也会申请失败。

而链表恰恰相反，它不需要连续的内存空间，而是使用指针将零散的内存块串联起来使用，所以针对上述问题如果我们申请的是 100 MB 的链表，根本不会有问题。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_1.jpg)

链表结构众多，主要包含单链表，双链表和循环链表。

## 1 单链表

单链表是最简单，也是最常用的。

链表通过指针将一组零散的内存块串联起来。其中，我们把内存块称为链表的**结点**。每个结点除了存储数据以外，为了串联数据，还需要记录下一个结点的位置。如图所示，我们记录下个结点地址的指针叫作**后继指针 next**。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/image/linked_list_2.jpg)

图中有两个结点比较特殊，分别是第一个结点（头结点）和最后一个结点（尾结点）。头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。尾结点为一个空地址 `NULL`，表示链表的结尾。

与数组一样，链表也支持查找、插入和删除操作。

在数组中插入或删除元素时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 `O(n)`。而链表的存储空间本身就不是连续的，并不需要搬移数据，所以链表的插入和删除操作是非常快速的。针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 `O(1)`。

<!-- image -->

虽然链表插入很快，但是如果想随机访问第 `k` 个元素，就没有数组那么高效了。因为链表中的数据不是连续存储的，无法直接通过寻址公式计算出节点的内存地址，而是要遍历每个节点，直到找到目标节点。所以对应的时间复杂度是 `O(n)`。

## 2 循环链表

**循环链表是一种特殊的单链表。**它跟单链表最大的区别就是尾节点的指向问题，单链表的尾节点指向空地址，而循环链表的尾节点指向链表的头节点，如图所示：

<!-- image -->