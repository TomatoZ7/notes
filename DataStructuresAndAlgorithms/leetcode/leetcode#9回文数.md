# leetcode 第九题：回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

### 示例1
```
输入：x = 121
输出：true
```

### 示例2
```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

### 示例3
```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

### 示例4
```
输入：x = -101
输出：false
```

## 思路

首先，把 x 转成字符串在进行比较，这种方法可行，但是转化开销大，效率低，不考虑。

其次，可以使用运算把 x 倒过来，再和 x 作 == 比较，但是这种情况下反转过来的 x 可能会存在溢出的情况，不太可取。

沿着这个思路下去，那么我们是否可以只反转一半，再与 x 作 == 比较，如果相等，那就是**回文数**。

| x | revertedNumber |
| :---: | :---: |
| 12123 | 0   |
| 1212  | 1   |
| 121   | 12  |
| 12    | 121 |

| x | revertedNumber |
| :---: | :---: |
| 123321 | 0   |
| 12332  | 1   |
| 1233   | 12  |
| 123    | 321 |

那么还存在 2 个问题需要我们考虑：

1. 什么时候才停止反转（如何才能判断反转了一半了）？

当 x <= revertedNumber 时，即可停止反转；

2. 当 x 是奇数位整数时，应该怎么判断？

可以使用 x == (revertedNumber / 10) 来判断。

## 解

```java
public boolean isPalindrome(int x) {
    // 过滤 负数 和 末位数是 0 的多位数
    if (x < 0 || (x % 10 == 0 && x != 0)){
        return false;
    }

    int tempInt = 0;
    while (tempInt < x) {
        tempInt = tempInt * 10 + x % 10;
        x /= 10;
    }

    if (x == tempInt || (x == (tempInt / 10))) {
        return true;
    }

    return false;
}
```

## 复杂度分析

+ 时间复杂度：O(logn)；
+ 空间复杂度：O(1)，我们只需要常数空间存放若干变量。