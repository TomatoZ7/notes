# LeetCode 第 141 题：环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中存在环，则返回 `true` 。 否则，返回 `false`。

**示例1**

![image:LeetCode_141_1](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/LeetCode/images/LeetCode_141_1.jpg)

```
输入：head = [3, 2, 0, -4]
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例2**

![image:LeetCode_141_1](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/LeetCode/images/LeetCode_141_2.jpg)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例3**

![image:LeetCode_141_1](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/LeetCode/images/LeetCode_141_3.jpg)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示**

+ 链表中结点的范围是 `[0, 10^4]`

+ `-10^5 <= Node.val <= 10^5`

**进阶**

你能用 `O(1)` 内存解决此问题吗？

**题解**

方法一：哈希表

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> hs = new HashSet<ListNode>();
	
        while (head != null) {
            if (!hs.add(head)) {
                return true;	
            }
            head = head.next;
        }
        
        return false;
    }
}
```

时间复杂度：`O(N)`

空间复杂度：`O(N)`

方法二：快慢指针

我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 `head`，而快指针在位置 `head.next`。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head.next;
        ListNode fast = head.next.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

时间复杂度：`O(N)`

+ 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。

当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 NN 轮。

空间复杂度：`O(1)`