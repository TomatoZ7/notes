# LeetCode 第 206 题：反转链表

给你单链表的头节点 `head`，请你反转链表，并返回反转后的链表。

**示例1**

![image:LeetCode_206_1](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/leetcode/images/LeetCode_206_1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例2**

![image:LeetCode_206_2](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/leetcode/images/LeetCode_206_2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例3**

```
输入：head = []
输出：[]
```

**提示**

+ 链表中结点的范围是 `[0,5000]`

+ `-5000 <= Node.val <= 5000`

**进阶**

链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

**题解**

方法一：迭代

在遍历链表时，将当前节点的 `next` 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev
            prev = curr
            curr = next
        }

        return prev;
    }
}
```

**传送门**

[https://leetcode-cn.com/problems/reverse-linked-list/](https://leetcode-cn.com/problems/reverse-linked-list/)