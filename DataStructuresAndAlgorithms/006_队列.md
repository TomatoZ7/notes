# 队列

## 1.如何理解队列

队列这个概念非常好理解，你可以把它想象成排队买票，先来的先买，后来的只能站队尾，不能插队。先进者先出，这就是典型的**队列（Queue）**。

我们知道，栈只支持两个基本操作：**入栈 `push` **和**出栈 `pop`**。队列与栈非常相似，最基本的操作也是两个：**入队 `enqueue`**，把一个数据放入队尾；**出队 `dequeue`**，从队列头部取一个元素。

![image:queue_1](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_1.jpg)

所以，队列和栈一样，也是一种**操作受限的线性表数据结构**。

作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有额外特性的队列，比如**循环队列**，**阻塞队列**，**并发队列**。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 `Disruptor`、Linux 环形缓存，都用到了循环并发队列；Java `concurrent` 并发包利用 `ArrayBlockingQueue` 来实现公平锁等。

## 2.顺序队列和链式队列

跟栈一样，队列既可以用数组来实现，也可以用链表来实现。基于数组的称为**顺序队列**，基于链表的称为**链式队列**。

### 2.1 顺序队列

顺序队列源码：

```java
public class ArrayQueue
{
    private String[] items;     // 存储队列元素的数组
    private int n;      // 表示队列大小
    private int head;   // 队列头指针
    private int tail;   // 队列尾指针

    // 申请一个大小为 capacity 的数组
    public ArrayQueue(int capacity) 
    {
        items = new String[capacity];
        n = capacity;
    }

    // 入队
    public boolean enqueue(String item) 
    {
        // 如果队列已满，返回 false
        if (tail == n) {
            return false;
        }

        items[tail] = item;
        ++tail;
        return true;
    }

    // 出队
    public String dequeue() 
    {
        // 如果队列为空，返回 null
        if (tail == head) {
            return null;
        }

        String res = items[head];
        ++head;
        return res;
    }
}
```

对于栈来说，我们需要一个栈顶指针就足够了。但是队列需要两个指针，一个 `head` 指向队头，一个 `tail` 指向队尾。当有数据入队时，`tail` 指针右移；当有数据出队时，`head` 指针右移。

![image:queue_2](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_2.jpg)

你会发现，随着 `head` 和 `tail` 指针的偏移，当 `tail` 偏移到数组末尾时，即使数组中还有空闲空间，也无法再进行入队操作。针对这种情况，我们该如何解决呢？

可以使用**数组搬移**，当然，不是每出队一次就将队列数据搬移一次，这样会造成出队的时间复杂度变为 `O(n)`。我们只需要在入队时判断 `tail` 指针指向末尾（即本次操作没有多余的空间供元素入队）时触发一次数据的搬移操作。借助这个思想，出队函数 `dequeue` 不变，入队函数 `enqueue` 稍加改造一下即可：

```java
public boolean enqueue(String item) 
{
    if (tail == n) {
        if (head == 0) {
            // 说明队列满了
            return false;
        }

        for (int i = head; i < tail; ++i) {
            items[i - head] = items[i];
        }
        // 搬移完后更新 head 和 tail
        tail -= head;
        head = 0;
    }

    items[tail] = item;
    ++tail;
    return true;
}
```

基于这种思路，出队的时间复杂度仍然是 `O(1)`，入队的时间复杂度根据均摊算法，也仍然是 `O(1)`。

### 2.2 链式队列

基于链表实现队列，我们同样需要两个指针 `head` 和 `tail`，`head` 指针指向链表头结点，`tail` 指针指向链表尾结点。入队时，`tail->next = newNode`，`tail = newNode`；出队时，`head = head->next`。

```java
public class LinkedListQueue
{
    private Node head = null;
    private Node tail = null;

    // 入队
    public boolean enqueue(Stirng data) 
    {
        if (head == null) {
            Node newNode = new Node(data, null);
            head = newNode;
            tail = newNode;
        } else {
            Node newNode = new Node(data, null);
            tail.next = newNode;
            tail = newNode;
        }
    }

    // 出队
    public String dequeue()
    {
        if (head == null) {
            return null;
        }

        String res = head.data;
        head = head.next;
        if (head == null) {
            tail = null;
        }
        return res;
    }

    /**
     * 内置结点类
     */
    private class Node
    {
        private Stirng data;
        private Node next;

        public Node(String data, Node next) {
            this.data = data;
            this.next = next;
        }

        public String getData()
        {
            return this.data;
        }
    }
}
```