# 队列

## 1.如何理解队列

队列这个概念非常好理解，你可以把它想象成排队买票，先来的先买，后来的只能站队尾，不能插队。先进者先出，这就是典型的**队列（Queue）**。

我们知道，栈只支持两个基本操作：**入栈 `push` **和**出栈 `pop`**。队列与栈非常相似，最基本的操作也是两个：**入队 `enqueue`**，把一个数据放入队尾；**出队 `dequeue`**，从队列头部取一个元素。

![image:queue_1](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_1.jpg)

所以，队列和栈一样，也是一种**操作受限的线性表数据结构**。

作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有额外特性的队列，比如**循环队列**，**阻塞队列**，**并发队列**。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 `Disruptor`、Linux 环形缓存，都用到了循环并发队列；Java `concurrent` 并发包利用 `ArrayBlockingQueue` 来实现公平锁等。

## 2.顺序队列和链式队列

跟栈一样，队列既可以用数组来实现，也可以用链表来实现。基于数组的称为**顺序队列**，基于链表的称为**链式队列**。

### 2.1 顺序队列

顺序队列源码：

```java
public class ArrayQueue
{
    private String[] items;     // 存储队列元素的数组
    private int n;      // 表示队列大小
    private int head;   // 队列头指针
    private int tail;   // 队列尾指针

    // 申请一个大小为 capacity 的数组
    public ArrayQueue(int capacity) 
    {
        items = new String[capacity];
        n = capacity;
    }

    // 入队
    public boolean enqueue(String item) 
    {
        // 如果队列已满，返回 false
        if (tail == n) {
            return false;
        }

        items[tail] = item;
        ++tail;
        return true;
    }

    // 出队
    public String dequeue() 
    {
        // 如果队列为空，返回 null
        if (tail == head) {
            return null;
        }

        String res = items[head];
        ++head;
        return res;
    }
}
```

对于栈来说，我们需要一个栈顶指针就足够了。但是队列需要两个指针，一个 `head` 指向队头，一个 `tail` 指向队尾。当有数据入队时，`tail` 指针右移；当有数据出队时，`head` 指针右移。

![image:queue_2](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_2.jpg)

你会发现，随着 `head` 和 `tail` 指针的偏移，当 `tail` 偏移到数组末尾时，即使数组中还有空闲空间，也无法再进行入队操作。针对这种情况，我们该如何解决呢？

可以使用**数组搬移**，当然，不是每出队一次就将队列数据搬移一次，这样会造成出队的时间复杂度变为 `O(n)`。我们只需要在入队时判断 `tail` 指针指向末尾（即本次操作没有多余的空间供元素入队）时触发一次数据的搬移操作。借助这个思想，出队函数 `dequeue` 不变，入队函数 `enqueue` 稍加改造一下即可：

```java
public boolean enqueue(String item) 
{
    if (tail == n) {
        if (head == 0) {
            // 说明队列满了
            return false;
        }

        for (int i = head; i < tail; ++i) {
            items[i - head] = items[i];
        }
        // 搬移完后更新 head 和 tail
        tail -= head;
        head = 0;
    }

    items[tail] = item;
    ++tail;
    return true;
}
```

基于这种思路，出队的时间复杂度仍然是 `O(1)`，入队的时间复杂度根据均摊算法，也仍然是 `O(1)`。

### 2.2 链式队列

基于链表实现队列，我们同样需要两个指针 `head` 和 `tail`，`head` 指针指向链表头结点，`tail` 指针指向链表尾结点。入队时，`tail->next = newNode`，`tail = newNode`；出队时，`head = head->next`。

```java
public class LinkedListQueue
{
    private Node head = null;
    private Node tail = null;

    // 入队
    public boolean enqueue(Stirng data) 
    {
        if (head == null) {
            Node newNode = new Node(data, null);
            head = newNode;
            tail = newNode;
        } else {
            Node newNode = new Node(data, null);
            tail.next = newNode;
            tail = newNode;
        }
    }

    // 出队
    public String dequeue()
    {
        if (head == null) {
            return null;
        }

        String res = head.data;
        head = head.next;
        if (head == null) {
            tail = null;
        }
        return res;
    }

    /**
     * 内置结点类
     */
    private class Node
    {
        private Stirng data;
        private Node next;

        public Node(String data, Node next) {
            this.data = data;
            this.next = next;
        }

        public String getData()
        {
            return this.data;
        }
    }
}
```

## 3.循环队列

我们刚才用数组实现队列的时候，当 `tail == n` 的时候，会有数据搬移操作。有没有一种方法，可以避免数据搬移操作的发生，提高入队性能，我们来看看循环队列的结局思路。

循环队列，顾名思义，长得像环一样。原本数组有头有尾，是一条直线。现在我们把它首尾相连，掰成了一个环，如图所示：

![image:queue_3](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_3.jpg)

我们可以发现，图中这个队列的大小为 8，当前 `head = 4`，`tail = 7`。现在我们入队 `d` 元素，将 `d` 元素置于 7 位置，这时候我们并不把 `tail` 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 `b` 入队时，我们将 `b` 置于 0 位置，`tail` 更新为 1。所以，在 `a`，`b` 依次入队后，循环队列中的元素就变成了下面这个样子：

![image:queue_4](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_4.jpg)

通过这样的方法，我们成功避免了数据搬移的操作，但是相对地，循环队列的代码实现要比普通队列复杂，最关键在于**队满**和**队空**情况的判断。

队空的情况下，`head == tail`；队满的情况下， 一般情况下，我们可以看出来，当队列满时，`tail + 1 = head`。但是，有个特殊情况，当 `tail = n - 1`，而 `head = 0` 时，这时候，`tail + 1 = n`，而 `head = 0`，所以使用 `(tail+1) % n` 的值，通过对 `n` 取余，才能得到 `head` 的真实值。而且，`tail+1` 最大的情况就是 `n`，不会大于 `n`，这样，`tail + 1` 除了最大情况，不然怎么余 `n` 都是 `tail+1` 本身，也就是 `head`。所以，正确的队满判断公式就是：`(tail + 1)% n = head`。

![image:queue_5](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_5.jpg)

从上图我们得知，队满的情况下，循环队列会浪费一个数组空间。

实现代码：

```java
public class CircularQueue
{
    private int head = 0;
    private int tail = 0;
    private String[] items;
    // 记录数组的长度
    private int n = 0;

    /**
     * 声明一个指定长度的队列
     */
    public CircularQueue(int capacity)
    {
        items = new String[capacity];
        n = capacity;
    }

    /**
     * 入队
     */
    public boolean enqueue(String item)
    {
        // 判断队满
        if ((tail + 1) % n == head) {
            return false;
        }

        String[tail] = item;
        tail = (tail + 1) % n;
        return true;
    }

    /**
     * 出队
     */
    public String dequeue()
    {
        // 判断队空
        if (head == tail) {
            return null;
        }

        String res = items[head];
        head = (head + 1) % n;
        return res;
    }
}
```

## 4.阻塞队列和并发队列

平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

你应该已经发现了，上述的定义就是一个“生产者 - 消费者模型”。是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”

这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。

不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。

![image:queue_6](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/queue_6.jpg)

前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？

线程安全的队列我们称为并发队列。最简单直接的方式就是在 `enqueue()`、`dequeue()` 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

## 5.线程池

我们知道，CPU 资源是有限的。任务的处理速度和线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？

我们一般有 2 种处理策略。第一种是非阻塞式的处理方式，直接拒绝处理请求；第二种是阻塞式处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？

我们希望公平地处理每个请求，先进者先服务，所以队列这种数据结构很适合拿来存储排队请求。我们前面介绍过队列可以基于数组或基于链表来实现，那么这两种实现方式对于排队请求又有什么区别呢？

基于链表的实现方式，可以实现一个支持无限排队的**无界队列（unbounded queue）**，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。

而基于数组实现的**有界队列（bounded queue）**，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。

<!-- LeetCode 225，622 -->