# 数组

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

在这个定义中有几个关键词：

1. **线性表（linear List）**

线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。**除了数组，链表、栈、队列也是线性表结构。**

二叉树、堆、图等则是**非线性表**，也就是说它们存放的数据之间并不是简单的前后关系。

2. **连续的内存空间和相同的数据类型**

正是因为这两个限制，数组才能实现**随机访问**。但也正是因为这两个特性，导致数组的很多操作变得低效，如删除或添加数组元素，为了保证连续性，就需要做大量的数据搬移工作。

## 1 数组如何实现根据下标随机访问数组元素

我们拿一个长度为 10 的 `int` 类型的数组 `int[] a = new int[10]` 来举例。如图所示，计算机给数组 `a[10]` 分配了一块连续内存空间 1000 ~ 1039，内存块的首地址为 `base_address = 1000`。

```java
    int a[10]
0   a[0]    1000 - 1003
1   a[1]    1004 - 1007
2   a[2]    1008 - 1011
    ·
    ·
    ·
9   a[9]    1036 - 1039
```

我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素，它会首先通过下面的寻址公式，计算出钙元素存储的内存地址：

```java
a[i]_address = base_address + i * date_type_size
```

其中，`data_type_size` 表示数组中每个元素的大小。在这个例子中，数组存放的是 `int` 类型数据，所以 `data_type_size` 就是 4 个字节。

> 补充 : 如果是二维数组 `a[i][j]`，由于二维数组的存储也是连续的，所以存储地址应该是一维的地址加上二维的地址，寻址公式应为 `a[i][j]_address = base_address + (i * m + j) * data_type_size`

> 存在一个“说法”：数组查找的时间复杂度是 `O(1)`。
> 
> 其实是不准确的。即便是排好序的数组，用二分查找，时间复杂度也是 `O(logn)`。正确的表述应该是：数组支持随机访问，根据下标随机访问的时间复杂度是 `O(1)`。

## 2 低效的插入和删除操作

数组为了保证内存数据的连续性，会导致插入、删除这两个操作比较低效。

我们先来看插入操作。假设数组的长度为 `n`，如果需要插入一个数据到第 `k` 个位置，那么就需要将 `k` ~ `n` 这部分的元素都顺序地往后挪一位。下面分析一下时间复杂度：

如果在数组末尾插入元素，那么就不需要移动数据了，时间复杂度为 `O(1)`。如果在数组的开头插入元素，那么最坏时间复杂度就是 `O(n)`。由于我们在每个位置插入的概率一样，所以平均时间复杂度为 `(1+2+···+n)/n = O(n)`。

如果数组有序，我们在某个位置插入数据时，就必须搬迁数据；如果数组无序，如果要将元素插入数组中的第 `k` 个位置，就可以先将该位置上的数据搬到数组最后，再将要添加的元素放到该位置上即可。利用这种技巧，在特定场景下我们可以实现数组插入元素时间复杂度为 `O(1)`。

我们再来看删除操作。与插入操作类似，如果我们要删除第 `k` 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。

如果删除数组末尾的数据，则最好时间复杂度为 `O(1)`；如果删除开头数据，则最坏时间复杂度是 `O(n)`，平均时间复杂度为 `O(n)`。

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，效率会高很多，举例来看：

数组 `a[10]` 中存储了 8 个元素 `a`，`b`，`c`，`d`，`e`，`f`，`g`，`h`。现在，我们要依次删除 `a`，`b`，`c`。为了避免 `d`，`e`，`f`，`g`，`h` 这几个数据会被搬移 3 次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

## 3 警惕数组越界问题

首先分析一下这段代码的运行结果：

```c
int main(int argc, char* argv[])
{
    int i = 0;
    int arr[3] = {0};
    for (; i <= 3; i++) {
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

这段代码并不是打印三行 `hello world`，而是会无限打印。这是因为数组大小为 3，`a[0]`，`a[1]`，`a[2]`，而我们的代码因为书写错误，将 `for` 循环的结束条件 `i<3` 错写为 `i<=3`，所以当 `i=3` 时，数组 `a[3]` 访问越界。

我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，`a[3]` 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 `i` 的内存地址，那么 `a[3]=0` 就相当于 `i=0`，所以就会导致代码无限循环。

> 数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续的内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

但并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做，像 Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛出 `java.lang.ArrayIndexOutOfBoundsException`：

```java
int[] a = new int[3]
a[3] = 10
```

## 4 容器能否完全取代数组

针对数组类型，很多语言都提供了**容器类**，比如 Java 中的 `ArrayList`、C++ STL 中的 `vector`。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？

以 Java 为例，`ArrayList` 最大的优势就是**可以将很多数组操作的细节封装起来**。比如前面提到的数组插入、删除数据时需要搬移到其他数据等。同时它也支持**动态扩容**。每次存储空间不够时，它都会将空间自动扩容为 1.5 倍大小。不过，由于扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果能够事先知道数据大小，最好**在创建 `ArrayList` 的时候实现指定数据大小。**

数组和 `ArrayList` 的使用小结：

1. Java `ArrayList` 无法存储基本类型，比如 `int`、`long`，需要封装为 `Integer`、`Long` 类，而 `Autoboxing`、`Unboxing` 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，可以选用数组。

2. 如果提前知道数据大小，且对数据操作比较简单，用不到 `ArrayList` 提供的方法，那么可以使用数组。

3. 在多维数组的表示上，数组往往更加直观：`Object()[] array`，而使用容器的话需要这样定义：`ArrayList<ArrayList<object>> array`。

## 5 为什么大多数编程语言的数组要从 0 开始索引

从数组存储的内存模型上来看，索引即意味着**偏移（offset）**。如果用 0 作为索引头，那么内存地址的计算公式为：

```
a[k]_address = base_address + k * type_size
```

如果从 1 开始，那么就变为：

```
a[k]_address = base_address + (k - 1) * type_size
```

对 CPU 来说也就意味着多了一次减法指令，而数组作为非常基础的数据结构，通过索引随机访问元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。

> 不过可能也是历史原因。C 语言设计者用 0 开始计数数组下标后，Java、JavaScript 等语言也都效仿了 C 语言，或者说这在一定程度上减少了其他语言的学习成本，因此沿用同样的设计。
>
> 有的语言数组也不是从 0 开始计数的，如 MATLAB；而 Python 则支持负数索引。