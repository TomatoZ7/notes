# 最好、最坏、平均、均摊时间复杂度

本文主要介绍：

1. 最好情况时间复杂度（best case time complexity）
2. 最坏情况时间复杂度（worst case time complexity）
3. 平均情况时间复杂度（average case time complexity）
4. 均摊时间复杂度（amortized time complexity）

## 1 最好、最坏情况时间复杂度

来看下面代码：

```java
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) pos = i;
    }
    return pos;
}
```

这段代码要实现的功能是：在一个无序数组 `array` 中，查找变量 `x` 出现的位置，如果没有找到则返回 `-1`。根据之前推理，我们可以得出这段代码的时间复杂度是 `O(n)`。

但是，这段代码并不高效，当我们中途找到的时候，就不需要继续遍历了，所以可以稍作优化：

```java
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x){
            pos = i;
            break;
        }
    }
    return pos;
}
```

这个时候的时间复杂度还是 `O(n)` 吗？如果在第 1 个便找到并返回了，那么时间复杂度就是 `O(1)`，如果 `x` 不存在数组中，那么时间复杂度就是 `O(n)`。由此可见，不同情况下这段代码的时间复杂度并不相同。

为了表示代码在不同情况下不同的时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度。

最好情况时间复杂度就是在最理想的情况下，执行这段代码的时间复杂度。最坏情况时间复杂度就是在最糟糕的情况下，执行这段代码的时间复杂度。

## 2 平均情况时间复杂度


最好和最坏时间复杂度都是在极端的情况下产生的，概率并不大。为了更好地表示平均情况下的复杂度，我们引入平均时间复杂度。

平均复杂度该怎么分析呢？我们还是借助上面例子：

要查找变量 `x` 在数组中的位置，一共有 `n+1` 种情况：在数组 0 - `n-1` 处和不在数组中。我们把每种情况下，查找需要遍历的元素个数加起来，然后再除以 `n+1`，就可以得到需要遍历的元素个数的平均值，即：

```
(1+2+3+ ··· +n+n) / (n+1) = n(n+3) / 2(n+1)
```