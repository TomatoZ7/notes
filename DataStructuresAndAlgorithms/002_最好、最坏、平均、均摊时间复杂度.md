# 最好、最坏、平均、均摊时间复杂度

本文主要介绍：

1. 最好情况时间复杂度（best case time complexity）
2. 最坏情况时间复杂度（worst case time complexity）
3. 平均情况时间复杂度（average case time complexity）
4. 均摊时间复杂度（amortized time complexity）

## 1 最好、最坏情况时间复杂度

来看下面代码：

```java
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) pos = i;
    }
    return pos;
}
```

这段代码要实现的功能是：在一个无序数组 `array` 中，查找变量 `x` 出现的位置，如果没有找到则返回 `-1`。根据之前推理，我们可以得出这段代码的时间复杂度是 `O(n)`。

但是，这段代码并不高效，当我们中途找到的时候，就不需要继续遍历了，所以可以稍作优化：

```java
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x){
            pos = i;
            break;
        }
    }
    return pos;
}
```

这个时候的时间复杂度还是 `O(n)` 吗？如果在第 1 个便找到并返回了，那么时间复杂度就是 `O(1)`，如果 `x` 不存在数组中，那么时间复杂度就是 `O(n)`。由此可见，不同情况下这段代码的时间复杂度并不相同。

为了表示代码在不同情况下不同的时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度。

最好情况时间复杂度就是在最理想的情况下，执行这段代码的时间复杂度。最坏情况时间复杂度就是在最糟糕的情况下，执行这段代码的时间复杂度。

## 2 平均情况时间复杂度


最好和最坏时间复杂度都是在极端的情况下产生的，概率并不大。为了更好地表示平均情况下的复杂度，我们引入平均时间复杂度。

平均复杂度该怎么分析呢？我们还是借助上面例子：

要查找变量 `x` 在数组中的位置，一共有 `n+1` 种情况：在数组 0 - `n-1` 处和不在数组中。我们把每种情况下，查找需要遍历的元素个数加起来，然后再除以 `n+1`，就可以得到需要遍历的元素个数的平均值，即：

```
(1+2+3+ ··· +n+n) / (n+1) = n(n+3) / 2(n+1)
```

而大 O 时间复杂度表示法中可以忽略系数、低阶、常量，所以，上述公式简化之后，得到的时间复杂度就是 `O(n)`。

这个结论虽然是正确的，但是计算过程稍微有点问题：我们刚讲的 `n+1` 种情况，出现的概率并不一样。我们知道，要查找的变量 `x`，要么在数组里，要么就不在数组里，这两种情况对应的概率统计起来很麻烦，为了方便理解，我们假设这两种情况概率都为 1/2。另外，要查找的数据出现在 0 ~ n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0 ~ n-1 中任意位置的概率就是 1/(2n)。

因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了：

```
1 * 1/(2n) + 2 * 1/(2n) + 3 * 1/(2n) + ··· + n * 1/(2n) + n * 1/2 = (3n+1)/4
```

这个值就是概率论中的**加权平均值**，也叫做**期望值**，所以平均时间复杂度的全称应该是**加权平均时间复杂度**或者**期望时间复杂度**。

引入加权平均值后，再根据大 O 表示法去掉系数和常量，这段代码的加权平均时间复杂度仍然是 `O(n)`。

> 很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

## 3 均摊时间复杂度

均摊时间复杂度应用的场景比平均时间复杂度更加特殊、有限。

看一个特殊的例子：

```java
/**
 * array 表示一个长度为 n 的数组
 */
int[] array = new int[n]
int count = 0

void insert(int val) {
    if (count == array.length) {
        int sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum = sum + array[i];
        }

        array[0] = sum;
        count = 1;
    }

    array[count] = val;
    ++count;
} 
```

这段代码主要实现了往数组里插入数据的功能。当数组内元素个数达到上限之后，则将所有的元素相加并放在数组的第一位。

下面我们分析这段代码的时间复杂度。先用最好、最坏、平均时间复杂度来分析：

