# 复杂度分析

时间、空间复杂度能够帮助我们衡量算法代码的执行效率。

## 1 复杂度分析的必要性

通过把代码执行一遍，统计、监控得到算法的执行时间和占用的内存大小是非常主观的：

1. 测试环境中硬件的不同会对测试结果有很大的影响。

2. 测试结果受数据规模的大小影响。

如同一个排序算法不同数据的有序度、大小都会影响到最终结果。

**所以，我们需要一个不用具体的数据来测试，就可以粗略地股计算法的执行效率的方法。 ---- 复杂度分析**

## 2 大 O 复杂度表示法

算法的执行效率，粗略地讲，就是算法代码执行的时间。

我们尝试估算下面这段代码的执行时间：

```java
int cal(int n) {
    int sum = 0;
    int i = 1;
    for (; i <= n; ++i) {
        sum = sum + 1;
    }
    return sum;
}
```

从 `CPU` 的角度来看，每一行代码都执行着类似操作：**读数据-运算-写数据**。尽管每行代码对应的 `CPU` 执行的个数、时间都不一样。但是，我们只是粗略的估计，姑且认为每行代码的执行时间都一样，为 `unit_time`。

在这个假设的基础上，第 2 - 3 行代码分别需要 1 个 `unit_time` 的执行时间，第 4 - 5 行都运行 `n` 次，所以需要 `2n * unit_time` 的执行时间，所以这段代码的执行时间就是 `(2n + 2) * unit_time`。可以看出，**所有代码的执行时间 `T(n)` 与每行代码的执行次数成正比。**

我们再看这段代码：

```java
int cal(int n) {
    int sum = 0;
    int i = 1;
    int j = 1;
    for (; i <= n; ++j) {
        j = 1;
        for (; j <= n; ++j) {
            sum = sum + i * j;
        }
    }
}
```

遵循上述估算方式，第 2 - 4 行各需 1 个 `unit_time` 的执行时间，第 5、6 行循环运行 `n` 次，需要 `2n * unit_time` 执行时间，第 7、8 行循环运行 `n^2` 次，需要 `2n^2 * unit_time` 的执行时间。所以这段代码总执行时间为：`T(n) = (2n^2 + 2n + 3) * unit_time`。

但是通过这两段代码执行时间的推导过程，我们可以得出一个很重要的规律：**所有代码的执行时间 `T(n)` 与每行代码的执行次数 `f(n)` 成正比。**总结成公式：

```math
T(n) = O( f(n) )
```

其中 `T(n)` 表示代码执行时间；`n` 表示数据规模的大小；`f(n)` 表示每行代码执行的次数总和。因为这是一个公式，所以用 `f(n)` 来表示。公式中的 `O`，表示代码的执行时间 `T(n)` 与 `f(n)` 表示式成正比。