# 栈

关于栈，有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从上往下一个一个放；取的时候，我们也是从上往下一个一个地依次取。不能从中间任意抽取。**后进者先出，先进者后出。**这就是典型的栈结构。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/stack_1.jpg)

从栈的操作特性上来看，**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。

可能存在一种说法，相比数组和链表，栈带来的只有操作上的限制，并没有任何优势。那么直接使用数组或者链表不就可以了吗？

从功能上来说，数组或链表确实可以替代栈，但是特定的数据结构是对特定场景的抽象，而且数组和链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控，自然也更容易出错。

**当某个数据集合只涉及在一端插入和删除数据时，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。**

## 1 如何实现一个栈

从刚才栈的定义中，我们可以看出，栈主要包含两个操作，**入栈和出栈**。也就是在栈顶插入一个数据和在栈顶删除一个数据。理解了栈的定义之后，我们来看看如何用代码实现一个栈。

实际上，栈既可以用数组来实现，称为**顺序栈**；也可以用链表实现，称为**链式栈**。

基于数组实现的栈：

```java
public class ArrayStack
{
    private String[] items;  // 数组
    private int count;      // 栈中元素的大小
    private int n;          // 栈的大小

    // 初始化数组，申请一个大小为 n 的数组空间
    public ArrayStack(int n) {
        this.items = new String[n];
        this.count = 0;
        this.n = n;
    }

    // 入栈
    public boolean push(String item)
    {
        // 数组空间不够，直接返回 false，入栈失败
        if (n == count) {
            return false;
        }

        items[count] = item;
        ++count;
        return true;
    }

    // 出栈
    public String pop()
    {
        // 栈为空，直接返回 null
        if (count == 0) {
            return null;
        }

        String res = items[count-1];
        --count;
        return res;
    }
}
```

基于链表实现的栈：

```java
public class LinkedListStack
{
    private Node head = null;

    private static class Node {
        private int data;
        private Node next;

        public Node(int data, Node next) {
            this.data = data;
            this.next = next;
        }

        public int getData() {
            return data;
        }
    }

    public void push(int value) {
        Node newNode = new Node(value, null);
        if (head == null) {
            head = newNode;
        } else {
            newNode.next = head;
            head = newNode;
        }
    }

    /**
     * 用 -1 表示没有数据
     */
    public int pop() {
        if (head == null) {
            return -1;
        }

        int res = head.data;
        head = head.next;
        return res;
    }
}
```

了解了定义和基本操作，那么时间复杂度是多少呢？

时间复杂度和空间复杂度均是 `O(1)`，因为在入栈和出栈时都只对栈顶元素进行操作。

注意：这里的栈需存储 `n` 个数据，并不是说空间复杂度就是 `O(n)`。因为这 `n` 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本存储的数据空间外，算法运行还需要额外的存储空间。

## 2 支持动态扩容的数据栈

刚才基于数组实现的栈，是固定大小的，当栈满之后，就无法再继续往栈里添加元素了。尽管链式栈的大小不受限制，但要存储 `next` 指针，内存消耗相对较多。那我们如何基于数组实现一个可以动态扩容的栈呢？

数组的动态扩容是当数组的空间不够时，就重新申请一个更大的空间，将原来的数组中的数据拷贝过去，这样就实现了一个支持动态扩容的数组。所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组即可。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/stack_2.jpg)

接下来分析支持动态扩容的顺序栈所花费的时间、空间复杂度。

对于出栈操作来说，我们不会涉及内存的申请和数据的搬移，所以**出栈的时间复杂度**仍然是 `O(1)`。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，**入栈操作的时间复杂度**是 `O(1)`。但当空间不够时，就需要重新申请内存和数据搬移，所以**时间复杂度**就变成了 `O(n)`。

也就是说，对于入栈操作，最好情况时间复杂度是 `O(1)`，最坏时间复杂度是 `O(n)`。那平均情况下的时间复杂度又是多少呢？

我们可以用[均摊分析法](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/002_%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.md)来分析。为了分析方便，我们先设置一些前提条件：

1. 栈空间不够时，我们申请原来 2 倍的新空间；

2. 为了简化分析，假设只有入栈操作没有出栈操作；

3. 定义不涉及内存搬移的入栈操作为 `simple-push`，时间复杂度为 `O(1)`。

如果当前栈的大小为 K，并且已满，当再有新数据入栈时，就需要重新申请一个 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作都只需要一个 `simple-push` 操作就可以完成。如图所示：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/stack_3.jpg)

这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 `simple-push` 操作。将 K 个数据搬移均摊到 K 次入栈操作，那么每次入栈操作只需要一次数据搬移和 `simple-push` 操作。以此类推，入栈的均摊时间复杂度就是 `O(1)`。

> 通过这个案例分析，印证了均摊时间复杂度一般等于最好时间复杂度。

## 3 栈在函数中的应用

栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是**函数调用栈**。

我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成**栈**这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行结束时，将这个函数对应的栈帧出栈。为了更好的理解，我们来看下面这段代码：

```java
int main() {
    int a = 1;
    int res = 0;
    int ret = 0;
    ret = add(3, 5);
    res = a + ret;
    printf("%d", res);
    return 0;
}

int add(int x, int y) {
    int sum = 0;
    sum = x + y;
    return sum;
}
```

从代码中可以看出，`main()` 函数调用了 `add()` 函数，获取计算结果，并且将临时变量 `a` 相加，最后打印 `res` 的值。下图展示了该过程中函数调用栈的情况：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/stack_4.jpg)

## 4 栈在表达式求职中的应用

`34+13*9+44-12/3` 这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是一件难事，那么如何实现这样一个表达式求值的功能呢？

实际上，编译器就是通过两个栈来实现。其中一个保存操作数的栈，另一个是保存运算符的栈。

我们从左向右遍历表达式，如果遇到数字，则压入操作数栈；如果遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，则直接压栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算结果压入操作数栈，继续比较。

我将表达式 `3+5*8-6` 的计算过程画成了一张图：

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/stack_5.jpg)

## 5 浏览器的前进后退

如何实现浏览器的前进、后退功能？其实，只用两个栈也可以实现。

我们使用两个栈X、Y，我们将首次浏览的页面压入 X 栈。当点击后退时，从栈 X 中取出数据压入栈 Y 中；当点击前进时，从栈 Y 中取出数据压入栈 X 中。当栈 X 没有数据时，说明已经没有页面可以后退了；当栈 Y 没有数据时，说明没有页面可以前进了。

1. 比如你顺序查看了 a、b、c 三个页面，那么就将 a、b、c 依次入栈 X；

2. 这时候点击浏览器的后退按钮，从页面 c 后退到页面 a 后，我们就依次把 c 和 b 从栈中弹出，并且依次压入栈 Y 中；

3. 这时候点击前进按钮，则将栈 Y 栈顶的元素出栈并压入 X 栈：

4. 此时，通过页面 b 跳转到页面 d 了，则页面 c 无法再通过前进、后退来查看了，所以需要清空栈 Y。

![image](https://github.com/TomatoZ7/notes-of-tz/blob/master/DataStructuresAndAlgorithms/images/stack_6.jpg)