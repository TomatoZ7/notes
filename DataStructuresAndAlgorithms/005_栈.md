# 栈

关于栈，有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从上往下一个一个放；取的时候，我们也是从上往下一个一个地依次取。不能从中间任意抽取。**后进者先出，先进者后出。**这就是典型的栈结构。

<!-- image -->

从栈的操作特性上来看，**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。

可能存在一种说法，相比数组和链表，栈带来的只有操作上的限制，并没有任何优势。那么直接使用数组或者链表不就可以了吗？

从功能上来说，数组或链表确实可以替代栈，但是特定的数据结构是对特定场景的抽象，而且数组和链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控，自然也更容易出错。

**当某个数据集合只涉及在一端插入和删除数据时，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。**

## 1 如何实现一个栈

从刚才栈的定义中，我们可以看出，栈主要包含两个操作，**入栈和出栈**。也就是在栈顶插入一个数据和在栈顶删除一个数据。理解了栈的定义之后，我们来看看如何用代码实现一个栈。

实际上，栈既可以用数组来实现，称为**顺序栈**；也可以用链表实现，称为**链式栈**。

基于数组实现的栈：

```java
public class ArrayStack
{
    private String[] items;  // 数组
    private int count;      // 栈中元素的大小
    private int n;          // 栈的大小

    // 初始化数组，申请一个大小为 n 的数组空间
    public ArrayStack(int n) {
        this.items = new String[n];
        this.count = 0;
        this.n = n;
    }

    // 入栈
    public boolean push(String item)
    {
        // 数组空间不够，直接返回 false，入栈失败
        if (n == count) {
            return false;
        }

        items[count] = item;
        ++count;
        return true;
    }

    // 出栈
    public String pop()
    {
        // 栈为空，直接返回 null
        if (count == 0) {
            return null;
        }

        String res = items[count-1];
        --count;
        return res;
    }
}
```

基于链表实现的栈：

```java
public class LinkedListStack
{
    private Node head = null;

    private static class Node {
        private int data;
        private Node next;

        public Node(int data, Node next) {
            this.data = data;
            this.next = next;
        }

        public int getData() {
            return data;
        }
    }

    public void push(int value) {
        Node newNode = new Node(value, null);
        if (head == null) {
            head = newNode;
        } else {
            newNode.next = head;
            head = newNode;
        }
    }

    /**
     * 用 -1 表示没有数据
     */
    public int pop() {
        if (head == null) {
            return -1;
        }

        int res = head.data;
        head = head.next;
        return res;
    }
}
```

了解了定义和基本操作，那么时间复杂度是多少呢？

时间复杂度和空间复杂度均是 `O(1)`，因为在入栈和出栈时都只对栈顶元素进行操作。

注意：这里的栈需存储 `n` 个数据，并不是说空间复杂度就是 `O(n)`。因为这 `n` 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本存储的数据空间外，算法运行还需要额外的存储空间。

## 2 支持动态扩容的数据栈

刚才基于数组实现的栈，是固定大小的，当栈满之后，就无法再继续往栈里添加元素了。尽管链式栈的大小不受限制，但要存储 `next` 指针，内存消耗相对较多。那我们如何基于数组实现一个可以动态扩容的栈呢？

数组的动态扩容是当数组的空间不够时，就重新申请一个更大的空间，将原来的数组中的数据拷贝过去，这样就实现了一个支持动态扩容的数组。所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组即可。

<!-- image -->

接下来分析支持动态扩容的顺序栈所花费的时间、空间复杂度。

对于出栈操作来说，我们不会涉及内存的申请和数据的搬移，所以**出栈的时间复杂度**仍然是 `O(1)`。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，**入栈操作的时间复杂度**是 `O(1)`。但当空间不够时，就需要重新申请内存和数据搬移，所以**时间复杂度**就变成了 `O(n)`。

也就是说，对于入栈操作，最好情况时间复杂度是 `O(1)`，最坏时间复杂度是 `O(n)`。那平均情况下的时间复杂度又是多少呢？