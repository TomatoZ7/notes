# PHP 内存(垃圾)回收机制

## 概念
垃圾回收机制是一种动态存储分配的方案。它会自动释放程序不再需要的已分配的内存块。垃圾回收机制可以让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。在现在的流行各种语言当中，垃圾回收机制是新一代语言所共有的特征，如 Python、PHP、C#、Ruby 等都使用了垃圾回收机制。

## PHP5.3 之前的"垃圾回收"
只有 php5.3 版本以后的才有了所谓的新的垃圾回收机制 GC。

在 PHP5.3 版本之前,使用的垃圾回收机制是单纯的[引用计数](https://github.com/TomatoZ7/notes-of-tz/blob/master/php/php/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.md)。

即：
1. 每个内存对象都分配一个计数器，当内存对象被变量引用时，计数器+1；
2. 当变量引用撤掉后（执行 `unset()` 后），计数器-1；
3. 当计数器=0时，表明内存对象没有被使用，该内存对象则进行销毁，垃圾回收完成。

并且 PHP 在一个生命周期结束后就会释放此进程/线程所占的内容，这种方式决定了 PHP 在前期不需要过多考虑内存的泄露问题。

但是当两个或多个对象互相引用形成环状后，内存对象的计数器则不会消减为0；这时候，这一组内存对象已经没用了，但是不能回收，从而导致内存泄露的现象。

php5.3开始，使用了新的垃圾回收机制，在引用计数基础上，实现了一种复杂的算法，来检测内存对象中引用环的存在，以避免内存泄露。

## PHP5.3 之后的 GC

先说说 GC 的三个基本规则：

1. 如果一个 zval 容器的 `refcount` 增加，说明有新的变量(符号)指向这个容器，那么这个容器不会是垃圾，将被继续使用。

2. 如果一个 zval 容器的 `refcount` 减少到 0，说明没有变量(符号)指向这个容器，他就会被 php 引擎销毁。

3. 如果一个 zval 容器的 `refcount` 减少了，但是大于 0，那么这个容器就有可能是垃圾，就会被垃圾回收机制所管理。

怎么管理这些容器并判断哪些是垃圾呢？

当发现某个容器有可能是垃圾时，这个容器会被放进一个内存缓冲区，当缓冲区满了时，就会进行垃圾回收算法来找出垃圾并销毁。

这里具体的算法可以看看官方文档，我就用一个网友的总结来描述：

> 对于一个包含环形引用的数组，对数组中包含的每个元素的 zval 进行减 1 操作，之后如果发现数组自身的 zval 的 refcount 变成了 0，那么可以判断这个数组是一个垃圾。



[传送门](https://blog.csdn.net/u011957758/article/details/76864400)
[传送门](https://www.cnblogs.com/impy/p/7850955.html)
[传送门](https://zhuanlan.zhihu.com/p/130986001)