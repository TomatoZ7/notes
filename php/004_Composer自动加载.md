# Composer 自动加载

## 1.自动加载类型

Composer 提供了如下几种自动加载的规范：

+ PSR-0
+ PSR-4
+ classmap
+ files

更新 autoload 规则到对应的 autoload 配置文件使用 `composer dump-autoload` 命令。

### 1.1 PSR-0

现在这个标准已经过时了，这个标准主要考虑到了 PHP5.2 中 Code_Util_Score 这样的写法。如果代码结构如下：

```
├── honey
│   └── honey
│       ├── composer.json
│       └── lib
│           └── Code
│               └── Util
│                   └── Score.php
```

我们在项目的 `composer.json` 文件里进行 autoload 的声明：

```json
"autoload":{
    "psr-0": {
        "Code" : "vendor/honey/honey/lib/"
    }
}
```

然后在项目的根目录下执行如下命令来更新自动加载配置：

```sh
$ composer dump-autoload
```

然后查看 `vendor/composer/autoload_namespaces.php`：

```php
<?php
// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
    'Code' => array($vendorDir . '/honey/honey/lib'),
);
```

可以看到以 Code 为前缀的类名在 `vendor/honey/honey/lib` 目录下寻找，在加载 **Code_Util_Score** 这个类时会把下划线转化成目录分隔符。

### 1.2 PSR-4

在 PSR-4 里边需要定义一个命名空间前缀到路径的映射（相对于包的根目录），如果命名空间前缀 `Foo\` 指向一个文件目录 `src/`，当自动加载一个类时，比如 `Foo\Bar\Baz` 类，那么这个类的路径为 `src/Bar/Baz.php`，命名空间前缀可以不在路径之中。在 `composer.json` 中的命名空间必须以 `\` 结尾，以避免名字冲突，示例如下：

```json
{
    "autoload": {
        "psr-4": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": ""
        }
    }
}
```

如果想把多个目录下的文件放到同一个命名空间前缀下，可以用如下写法：

```json
{
    "autoload": {
        "psr-4": { "Monolog\\": ["src/", "lib/"] }
    }
}
```

### 1.3 classmap

classmap 引用的所有组合都会在 install/update 过程中生成，并存储到 `vendor/composer/autoload_classmap.php` 文件中。这个 map 是经过扫描指定目录（同样支持直接精确到文件）中所有的 `.php` 和 `.inc` 文件里内置的类而得到的。你可以用 classmap 生成支持自定义加载的不遵循 PSR-0/4 规范的类库。要配置它指向需要的目录，以便能够准确搜索到类文件。

```json
{
    "autoload": {
        "classmap": ["src/", "lib/", "Something.php"]
    }
}
```

### 1.4 file

如果你想要明确的指定，在每次请求时都要载入某些文件，那么你可以使用 files autoloading，通常作为函数库的载入方式（而非类库）。files 引用的所有集合都会在 install/update 过程中生成，并存储到 `vendor/composer/autoload_files.php` 文件中。

```json
{
    "autoload": {
        "files": ["src/MyLibrary/functions.php"]
    }
}
```

## 2.自动加载原理

在我们的项目根目录下创建一个 `composer.json`，在这个文件里声明我们的依赖：

```json
{
    "require": {
        "workerman/workerman": "^3.3"
    }
}
```

然后执行 `composer install` 就可以安装该依赖，Composer 会把依赖安装到 `vendor` 目录下并在 `vendor` 目录生成一个 `autoload.php` 文件，在项目中引入该 `autoload` 文件就可以使用 vendor 下面的库了。

```php
<?php
require_once 'vendor/autoload.php';

use Workerman\Worker;

$worker = new Worker('http://0.0.0.0:8080');

$worker->onMessage = function($connection, $data)
{
    $connection->send("Hello World");
};

// 运行worker
Worker::runAll();
```

接下来我们来看一下composer自动加载的奥秘吧。

### 2.1 vendor/autoload.php

这个文件是自动加载的入口文件，打开该文件内容如下：

```php
<?php
// autoload.php @generated by Composer

require_once __DIR__ . '/composer' . '/autoload_real.php';

return ComposerAutoloaderInit6b02afbbb0f09c7f4f45234765981b94::getLoader();
```

可以看到它引入了 `vendor/composer/autoload_real.php` 文件，调用了自动加载类的 `getLoader` 方法并将结果返回。

### 2.2 vendor/composer/autoload_real.php

```php
<?php
// autoload_real.php @generated by Composer

class ComposerAutoloaderInit6b02afbbb0f09c7f4f45234765981b94
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        //如果加载器已存在则直接返回
        if (null !== self::$loader) {
            return self::$loader;
        }

        //注册一个自动加载函数到__autoload函数栈中
        spl_autoload_register(array('ComposerAutoloaderInit6b02afbbb0f09c7f4f45234765981b94', 'loadClassLoader'), true, true);
        //实例化一个自动加载类并存储到静态变量里
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        //注销这个自动加载函数
        spl_autoload_unregister(array('ComposerAutoloaderInit6b02afbbb0f09c7f4f45234765981b94', 'loadClassLoader'));

        //版本判断看使用哪些自动加载的配置文件
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION');
        if ($useStaticLoader) {
            require_once __DIR__ . '/autoload_static.php';

            call_user_func(\Composer\Autoload\ComposerStaticInit6b02afbbb0f09c7f4f45234765981b94::getInitializer($loader));
        } else {
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        //调用加载器的注册方法注册自动加载函数include文件
        $loader->register(true);

        //加载一些函数文件
        if ($useStaticLoader) {
            $includeFiles = Composer\Autoload\ComposerStaticInit6b02afbbb0f09c7f4f45234765981b94::$files;
        } else {
            $includeFiles = require __DIR__ . '/autoload_files.php';
        }
        foreach ($includeFiles as $fileIdentifier => $file) {
            composerRequire6b02afbbb0f09c7f4f45234765981b94($fileIdentifier, $file);
        }

        return $loader;
    }
}
```

这就是 Composer 自动加载的过程。这里涉及到的文件如下所示： 

+ `vendor/autoload.php`： 自动加载入口文件 
+ `vendor/composer/autoload_real.php`：自动加载核心文件 
+ `vendor/composer/ClassLoader.php`：自动加载类具体实现文件
+ `vendor/composer/autoload_static.php`：所有的自动加载配置
+ `vendor/composer/autoload_classmap.php`：classmap 自动加载配置
+ `vendor/composer/autoload_namespaces.php`：PSR-0 自动加载配置
+ `vendor/composer/autoload_psr4.php`：PSR-4 自动加载配置
+ `vendor/composer/autoload_files.php`：files 自动加载配置