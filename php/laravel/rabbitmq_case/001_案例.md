# rabbitMQ 案例 (laravel)

## 官方 composer 配置

[English](https://www.rabbitmq.com/tutorials/tutorial-one-php.html)

[中文](https://learnku.com/articles/9117/rabbitmq-entry-work-queue)

## 创建连接工程

```php
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

// 创建连接 connection
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
// 通过连接获取通道 Channel
$channel = $connection->channel();

/** 
 *  通过通道创建交换机，声明队列 'hello'
 *  @param 队列的名称
 *  @param 是否持久化(非持久化会存盘，但随着服务器的重启而丢失)
 *  @param 排他性，是否是一个独占队列
 *  @param 最后一个消息消费完毕是否自动删除队列
 *  @param 携带附属参数
 */
$channel->queue_declare('hello', false, false, false, false);

...

while(count($channel->callbacks)) {
    $channel->wait();
}

// 关闭通道
$channel->close();
// 关闭连接
$connection->close();
```

> 以下模式都可以使用 `php artisan make:command ` 创建响应类来模拟。

## Simple 模式

```php
// 准备消息内容
$msg = new AMQPMessage('Hello World!');
// 发送消息给队列
$channel->basic_publish($msg, '', 'hello');
```

```php
echo ' [*] Waiting for messages. To exit press CTRL+C', "\n";

$callback = function($msg) {
    echo " [x] Received ", $msg->body, "\n";
};

$channel->basic_consume('hello', '', false, true, false, false, $callback);
```


## fanout 模式(发布订阅模式)

```php
$channel->exchange_declare('logs', 'fanout', false, false, false);
        
$msg = new AMQPMessage('info: Hello Fanout!');
$channel->basic_publish($msg, 'logs');

echo " [x] Sent info: Hello Fanout!\n";
```

```php
$channel->exchange_declare('logs', 'fanout', false, false, false);
        
list($queue_name, ,) = $channel->queue_declare("", false, false, true, false);

$channel->queue_bind($queue_name, 'logs');

echo ' [*] Waiting for logs. To exit press CTRL+C', "\n";

$callback = function($msg){
    echo ' [x] ', $msg->body, "\n";
};

$channel->basic_consume($queue_name, '', false, true, false, false, $callback);
```


## direct (路由)模式

```php
$channel->exchange_declare('direct_logs', 'direct', false, false, false);
        
$data = "Hello Direct!";
$msg = new AMQPMessage($data);

$severity = "info";

$channel->basic_publish($msg, 'direct_logs', $severity);

echo " [x] Sent ",$severity,':',$data," \n";
```

```php
$channel->exchange_declare('direct_logs', 'direct', false, false, false);
        
list($queue_name, ,) = $channel->queue_declare("", false, false, true, false);

$severities = ['info', 'warning', 'error'];

foreach($severities as $severity) {
    $channel->queue_bind($queue_name, 'direct_logs', $severity);
}

echo ' [*] Waiting for logs. To exit press CTRL+C', "\n";

$callback = function($msg){
    echo ' [x] ',$msg->delivery_info['routing_key'], ':', $msg->body, "\n";
};

$channel->basic_consume($queue_name, '', false, true, false, false, $callback);
```

## topic 模式

跟上述差不多，只不过是使用 `#`(匹配0级或多级) 和 `*`(匹配一级)进行侦听。