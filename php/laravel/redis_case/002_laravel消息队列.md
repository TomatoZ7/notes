# laravel 消息队列

一个完整的队列系统由以下三部分组成：

+ 队列(Queue)
+ 消息(Message)
+ 处理进程(Worker)

对应的基本工作流程是生产者(业务代码)先将消息数据推送到队列，然后再通过其他的处理进程来消费队列中的消息数据，从而实现生产者和消费者之间的解耦。

因此，消息队列非常适用于一些需要异步执行的耗时操作(比如邮件上传，文件上传)，或者业务临时的高并发操作(比如秒杀，消息推送)，对于提升系统性能和负载非常有效，尤其是 PHP 这种本身不支持并发编程的语言，是实现异步编程的不二之选。

在演示如何实现消息队列之前，我们先来简单介绍下上面的三个组件。

## 队列

队列是一种线性的数据结构，具有 FIFO(先进先出) 的特性，因此很适合做生产者和消费者之间的解耦，同时不影响业务逻辑的执行顺序。

我们可以使用 redis 的**列表**类型来实现队列。

我们可以将[上篇文章](001_热门浏览文章排行榜.md)的文章浏览数更新操作通过队列异步实现来提升系统性能。为了简化流程，我们通过 `post_views_increment` 来标识队列名称，推送到队列的消息数据通过文章 id 来标识：

```php
// 文章浏览数 +1
public function addViews(Post $post)
{
    // 推送消息数据到队列，通过异步进程处理数据库更新
    Redis::rpush('post-views-increment', $post->id);
    return ++$post->views;
}
```

## 消息

所谓消息，即推送到队列中的数据，通常是一个字符串，如果是非字符串数据，可以通过序列化操作将其转化为字符串，消费端的处理进程从队列中取出数据后，可以对其进行解析，完成业务逻辑的闭环。

生产者和消息本身不必关心消费端处理进程如何处理消息数据，消费端的处理进程也不用关心是谁发送的数据，三者是完全解耦的，但是又通过了消息数据架起了生产者和消费者之间的架梁。

消息数据可以在应用内传递，也可以跨应用传递。跨应用传递通常需要借助第三方消息队列中间件，比如：基于 redis 实现的队列系统，rabbitMQ，kafka，rocketMQ 等。

在上述示例代码中，我们使用文章 id 作为消息数据进行传递。

## 处理进程

消费端的处理进程通常是一个或者多个常驻内存的进程，它们或订阅或轮询消息队列，如果消息队列不为空，则取出其中的消息数据进行处理。

