# 如何保证缓存与数据库的一致性？

- [如何保证缓存与数据库的一致性？](#如何保证缓存与数据库的一致性)
  - [1.同步删除](#1同步删除)
    - [1.1 核心流程](#11-核心流程)
    - [1.2 存在的问题](#12-存在的问题)
  - [2.延迟双删](#2延迟双删)
    - [2.1 核心流程](#21-核心流程)
    - [2.2 存在的问题](#22-存在的问题)
  - [3.异步监听 binlog + 重试](#3异步监听-binlog--重试)
    - [3.1 核心流程](#31-核心流程)
    - [3.2 存在的问题](#32-存在的问题)
  - [4.缓存三重删除 + 数据一致性校验 + 更新流程禁用缓存 + 强制读 Redis 主节点](#4缓存三重删除--数据一致性校验--更新流程禁用缓存--强制读-redis-主节点)
    - [4.1 缓存三重删除](#41-缓存三重删除)
    - [4.2 数据一致性校验](#42-数据一致性校验)
    - [4.3 更新流程禁用缓存](#43-更新流程禁用缓存)
    - [4.4 强制读 Redis 主节点](#44-强制读-redis-主节点)

## 1.同步删除

### 1.1 核心流程

1. 更新数据库数据
2. 删除缓存数据

### 1.2 存在的问题

1. 并发场景下会存在脏数据

例子：表 A 存在数据 a = 1，并发情况下可能有以下流程：

| 时序 | 线程 1 | 线程 2 |
| :--: | :--: | :--: |
| 1 |  | 查询数据库 a = 1 |
| 2 | 更新数据库 a = 2 |  |
| 3 | 删除缓存数据 |  |
| 4 |  | 将数据写入缓存 a = 1 | 

2. 难以收拢所有的更新数据库入口

比如在一些可视化数据库管理平台（PHPMYADMIN、NAVICAT）就无法做到删除缓存。

3. 删除缓存失败存在脏数据

## 2.延迟双删

### 2.1 核心流程

1. 删除缓存数据
2. 更新数据库数据
3. 等待一小段时间
4. 再次删除缓存数据

### 2.2 存在的问题

1. 延时时间难以确认
2. 延时无法绝对保障数据一致性

例子：表 A 存在数据 a = 1，并发情况下可能有以下流程：

| 时序 | 线程 1 | 线程 2 | 线程 3 |
| :--: | :--: | :--: | :--: |
| 1 | 删除缓存数据 |  |  |
| 2 | 更新主库 a = 2 |  |  |
| 3 | 再次删除缓存 |  |  |
| 4 |  | 查询从库数据 a = 1 |  |
| 5 |  | 将数据写入缓存 a = 1（脏） |  |
| 6 |  |  | 数据同步从库 a = 2 |

## 3.异步监听 binlog + 重试

### 3.1 核心流程

1. 更新数据库
2. 监听 binlog，删除缓存
3. 缓存删除失败则通过 MQ 不断重试，直到删除成功

![image](Images/consistency_1.png)

### 3.2 存在的问题

1. 有脏数据窗口
2. 极端场景下存在长期脏数据问题
   1. binlog 抓取组件宕机
   2. 拆库拆表流程

表 A 正在进行数据库拆分，当前进行到灰度切读流量阶段：部分读新库，部分读老库。

数据库拆分大致流程：增量数据同步（双写）、全量数据迁移、数据一致性校验、**灰度切读**、切读完毕后停写老库。

例子：此时表 A 存在数据 a = 1，并发情况下可能有以下流程：

| 时序 | 线程 1 | 线程 2 | 线程 3 |
| :--: | :--: | :--: | :--: |
| 1 | 更新老库数据：a = 2 |  |  |
| 2 | 异步监听 binlog 删除缓存 |  |  |
| 3 |  | 查询新库数据 a = 1 |  |
| 4 |  |  | 老库数据同步到新库 a = 2 |
| 5 |  | 将数据写入缓存 a = 1（脏） |  |

## 4.缓存三重删除 + 数据一致性校验 + 更新流程禁用缓存 + 强制读 Redis 主节点

### 4.1 缓存三重删除

+ **更新数据库后同步删除**。主要是解决异步监听 binlog 存在较长的脏数据窗口问题。
+ **监听数据库的 binlog 异步删除缓存**。主要是应对并发，带重试，保障一定会最终删除成功。
+ **缓存数据带过期时间**，过期后自动删除，越近更新的数据过期时间越短。
  + 主要用于进一步防止并发下的脏数据问题。
  + 解决一些由于未知情况，导致需要更换缓存结构的问题。

### 4.2 数据一致性校验

监听数据库的 binlog 延迟 N 秒后进行数据的一致性校验。解决一些极端场景下的脏数据问题，比如前面异步监听 binlog 存在的拆库拆表问题。

接下来是几个优化的点。

### 4.3 更新流程禁用缓存

存在数据库更新的链路禁用对应缓存，比如更新完数据后需要马上查询的场景，防止并发下短期内的脏数据影响到更新流程。

### 4.4 强制读 Redis 主节点

防止因主从同步带来的数据不一致问题。